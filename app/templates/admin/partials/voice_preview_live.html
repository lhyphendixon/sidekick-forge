<!-- Live Voice Chat Interface with LiveKit Client -->
<div class="h-96 flex flex-col p-4">
    <!-- Status Header -->
    <div class="text-center mb-4">
        <div id="connectionStatus" class="flex items-center justify-center gap-2 mb-2">
            <div class="w-3 h-3 rounded-full bg-yellow-500 animate-pulse" id="statusIndicator"></div>
            <span class="text-sm text-dark-text-secondary" id="statusText">Connecting to voice room...</span>
        </div>
        <p class="text-xs text-dark-text-secondary">Room: {{ room_name }}</p>
    </div>
    
    <!-- Audio Visualization -->
    <div class="flex-1 flex items-center justify-center">
        <div id="audioContainer" class="text-center">
            <!-- Microphone Status -->
            <div class="mb-6">
                <div id="micIcon" class="w-20 h-20 mx-auto mb-2 text-dark-text-secondary">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
                    </svg>
                </div>
                <p class="text-sm text-dark-text" id="micStatus">Microphone: Checking...</p>
            </div>
            
            <!-- Audio Level Indicator -->
            <div class="max-w-xs mx-auto mb-4 hidden" id="audioLevelContainer">
                <div class="h-2 bg-dark-elevated rounded-full overflow-hidden">
                    <div id="audioLevel" class="h-full bg-brand-teal transition-all duration-100 ease-out" style="width: 0%"></div>
                </div>
                <p class="text-xs text-dark-text-secondary mt-1">Audio Level</p>
            </div>
            
            <!-- Agent Status -->
            <div id="agentStatus" class="hidden">
                <p class="text-sm text-brand-teal mb-2">Agent Connected</p>
                <p class="text-xs text-dark-text-secondary">Listening for "{{ agent_slug or (agent.slug if agent else 'agent') }}"</p>
            </div>
        </div>
    </div>
    
    <!-- Controls -->
    <div class="border-t border-dark-border pt-4">
        <div class="flex justify-center gap-3">
            <!-- Mute Button -->
            <button id="muteBtn" 
                    onclick="toggleMute()"
                    class="p-3 rounded-full bg-dark-elevated text-dark-text hover:bg-dark-border transition-all disabled:opacity-50"
                    disabled>
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
                </svg>
            </button>
            
            <!-- Disconnect Button -->
            <button id="disconnectBtn"
                    hx-post="/admin/agents/preview/{{ client_id }}/{{ agent_slug }}/voice-stop"
                    hx-vals='{"session_id": "{{ session_id }}", "room_name": "{{ room_name }}"}'
                    hx-target="#voiceStatus"
                    hx-swap="innerHTML"
                    onclick="disconnectVoice()"
                    class="px-4 py-2 bg-brand-salmon text-white rounded-lg hover:bg-brand-salmon/90 transition-all flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
                Disconnect
            </button>
        </div>
    </div>
</div>

<script>
// Wrap entire script in IIFE to avoid global conflicts
(function() {
    // Ensure LiveKit SDK is loaded
    if (!window.LivekitClient && !document.querySelector('script[src*="livekit-client"]')) {
        const script = document.createElement('script');
        script.src = '/static/livekit-client.min.js';
        script.onload = () => {
            console.log('LiveKit SDK loaded dynamically');
            window.LiveKitSDK = window.LivekitClient;
        };
        script.onerror = () => {
            console.error('Failed to load LiveKit SDK');
        };
        document.head.appendChild(script);
    }

    // LiveKit connection variables - use local scope within IIFE
    let room = null;
    let localParticipant = null;
    let audioTrack = null;
    let isMuted = false;

// Wait for LiveKit SDK to be available
async function waitForLiveKitSDK() {
    let attempts = 0;
    const maxAttempts = 20; // 10 seconds max wait
    
    while (attempts < maxAttempts) {
        // Check various possible SDK locations
        if (window.LiveKitSDK || window.LivekitClient || window.LiveKit || window.livekit || 
            typeof LivekitClient !== 'undefined' || typeof LiveKit !== 'undefined' || typeof livekit !== 'undefined') {
            console.log('LiveKit SDK found after', attempts * 500, 'ms');
            return true;
        }
        
        attempts++;
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    console.error('LiveKit SDK not found after', maxAttempts * 500, 'ms');
    return false;
}

// Initialize LiveKit connection
async function initializeLiveKit() {
    try {
        // Wait for SDK to be available
        const sdkAvailable = await waitForLiveKitSDK();
        if (!sdkAvailable) {
            console.error('LiveKit client SDK not loaded after waiting');
            updateStatus('error', 'LiveKit client SDK not loaded');
            return;
        }
        
        // Check if LiveKit client is loaded - use the consistent global variable
        let LiveKitSDK;
        if (window.LiveKitSDK) {
            LiveKitSDK = window.LiveKitSDK;
        } else if (typeof LivekitClient !== 'undefined') {
            LiveKitSDK = LivekitClient;
        } else if (typeof LiveKit !== 'undefined') {
            LiveKitSDK = LiveKit;
        } else if (typeof livekit !== 'undefined') {
            LiveKitSDK = livekit;
        } else if (window.LivekitClient) {
            LiveKitSDK = window.LivekitClient;
        } else if (window.LiveKit) {
            LiveKitSDK = window.LiveKit;
        } else if (window.livekit) {
            LiveKitSDK = window.livekit;
        } else {
            console.error('LiveKit client SDK not loaded - tried LiveKitSDK, LivekitClient, LiveKit, livekit');
            updateStatus('error', 'LiveKit client SDK not loaded');
            return;
        }
        console.log('LiveKit client SDK loaded successfully as:', LiveKitSDK);
        
        // Debug: Log connection details
        console.log('LiveKit Connection Details:');
        console.log('Server URL:', '{{ server_url }}');
        console.log('User Token length:', '{{ user_token }}'.length);
        console.log('User Token:', '{{ user_token }}'.substring(0, 50) + '...');
        console.log('Room Name:', '{{ room_name }}');
        console.log('Template variables check:');
        console.log('- server_url empty?', '{{ server_url }}' === '');
        console.log('- user_token empty?', '{{ user_token }}' === '');
        console.log('- room_name empty?', '{{ room_name }}' === '');
        
        // Validate required variables
        if (!('{{ server_url }}') || !('{{ user_token }}') || !('{{ room_name }}')) {
            console.error('Missing required template variables');
            updateStatus('error', 'Missing connection configuration');
            return;
        }
        
        // Update status
        updateStatus('connecting', 'Requesting microphone permissions...');
        
        // Request microphone permission first
        try {
            await navigator.mediaDevices.getUserMedia({ audio: true });
            console.log('‚úÖ Microphone permission granted');
            updateStatus('connecting', 'Connecting to voice room...');
        } catch (permError) {
            console.error('‚ùå Microphone permission denied:', permError);
            updateStatus('error', 'Microphone permission required');
            return;
        }
        
        // Create room instance
        room = new LiveKitSDK.Room({
            // Adaptive stream for better performance
            adaptiveStream: true,
            // Automatic quality adjustment
            dynacast: true,
            // Log level for debugging
            logLevel: 'warn'
        });
        
        // Store room reference globally for cleanup
        window.livekitRoom = room;
        
        // Set up event handlers
        room.on('connected', handleConnected);
        room.on('disconnected', handleDisconnected);
        room.on('participantConnected', handleParticipantConnected);
        room.on('participantDisconnected', handleParticipantDisconnected);
        room.on('activeSpeakersChanged', handleActiveSpeakers);
        room.on('localTrackPublished', handleLocalTrackPublished);
        room.on('dataReceived', handleDataReceived);
        room.on('error', handleError);
        
        // Connect to room with timeout
        console.log('Attempting to connect to room...');
        console.log('Using LiveKit client version:', LiveKitSDK.version || 'unknown');
        const connectStart = Date.now();
        
        // Try connection with detailed error handling
        try {
            await room.connect('{{ server_url }}', '{{ user_token }}');
            const connectTime = Date.now() - connectStart;
            console.log(`‚úÖ Connection successful in ${connectTime}ms`);
        } catch (connectError) {
            console.error('‚ùå Connection failed:', connectError);
            console.error('Connection error type:', connectError.constructor.name);
            console.error('Connection error message:', connectError.message);
            
            // Provide more specific error messages
            if (connectError.message.includes('timeout')) {
                throw new Error('Connection timed out. Please check your network.');
            } else if (connectError.message.includes('unauthorized') || connectError.message.includes('401')) {
                throw new Error('Authentication failed. Invalid token.');
            } else if (connectError.message.includes('network') || connectError.message.includes('NETWORK')) {
                throw new Error('Network error. Please check your connection.');
            } else {
                throw connectError;
            }
        }
        
    } catch (error) {
        console.error('Failed to initialize LiveKit:', error);
        console.error('Error details:', {
            name: error.name,
            message: error.message,
            stack: error.stack
        });
        updateStatus('error', 'Failed to connect: ' + error.message);
    }
}

// Handle successful connection
async function handleConnected() {
    console.log('Connected to LiveKit room');
    updateStatus('connected', 'Connected to voice room');
    
    // Enable mute button
    document.getElementById('muteBtn').disabled = false;
    
    // Request microphone permission and publish audio
    try {
        await room.localParticipant.setMicrophoneEnabled(true);
        updateMicStatus('Microphone: Active');
        document.getElementById('audioLevelContainer').classList.remove('hidden');
    } catch (error) {
        console.error('Microphone error:', error);
        updateMicStatus('Microphone: ' + error.message);
    }
}

// Handle disconnection
function handleDisconnected() {
    console.log('Disconnected from LiveKit room');
    updateStatus('disconnected', 'Disconnected from voice room');
    document.getElementById('muteBtn').disabled = true;
}

// Handle participant connected (agent)
function handleParticipantConnected(participant) {
    console.log('Participant connected:', participant.identity);
    if (participant.identity.includes('agent')) {
        document.getElementById('agentStatus').classList.remove('hidden');
        updateStatus('agent-connected', 'Agent connected - Ready to chat');
    }
}

// Handle participant disconnected
function handleParticipantDisconnected(participant) {
    console.log('Participant disconnected:', participant.identity);
    if (participant.identity.includes('agent')) {
        document.getElementById('agentStatus').classList.add('hidden');
        updateStatus('connected', 'Agent disconnected');
    }
}

// Handle active speakers (audio level visualization)
function handleActiveSpeakers(speakers) {
    // Update audio level for local participant
    const localSpeaker = speakers.find(s => s.identity === room.localParticipant.identity);
    if (localSpeaker) {
        const level = Math.min(100, localSpeaker.audioLevel * 100);
        document.getElementById('audioLevel').style.width = level + '%';
    } else {
        document.getElementById('audioLevel').style.width = '0%';
    }
}

// Handle local track published
function handleLocalTrackPublished(publication) {
    if (publication.kind === 'audio') {
        audioTrack = publication.track;
        console.log('Audio track published');
    }
}

// Handle data messages from agent
function handleDataReceived(payload, participant) {
    console.log('üì® Data received from:', participant?.identity, payload);
    
    try {
        const decoder = new TextDecoder();
        const message = JSON.parse(decoder.decode(payload));
        console.log('üìù Agent message:', message);
        
        if (message.type === 'agent_response') {
            // Display agent response in UI
            const statusText = document.getElementById('statusText');
            if (statusText) {
                statusText.textContent = `Agent: ${message.message}`;
                updateStatus('agent-responding', `Agent: ${message.message}`);
            }
            
            // Could also show in a dedicated chat area
            showAgentMessage(message.message);
        }
    } catch (error) {
        console.error('Error parsing agent message:', error);
    }
}

// Show agent message in UI
function showAgentMessage(message) {
    // Find or create a messages container
    let messagesContainer = document.getElementById('agentMessages');
    if (!messagesContainer) {
        messagesContainer = document.createElement('div');
        messagesContainer.id = 'agentMessages';
        messagesContainer.className = 'mt-4 p-3 bg-dark-elevated rounded-lg border border-dark-border';
        
        // Insert after the agent status div
        const agentStatus = document.getElementById('agentStatus');
        if (agentStatus && agentStatus.parentNode) {
            agentStatus.parentNode.insertBefore(messagesContainer, agentStatus.nextSibling);
        }
    }
    
    // Add the message
    const messageDiv = document.createElement('div');
    messageDiv.className = 'text-sm text-dark-text mb-2 p-2 bg-brand-teal/10 rounded border-l-2 border-brand-teal';
    messageDiv.innerHTML = `<strong>Agent:</strong> ${message}`;
    messagesContainer.appendChild(messageDiv);
    
    // Scroll to bottom
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    
    // Limit to last 5 messages
    const messages = messagesContainer.children;
    while (messages.length > 5) {
        messagesContainer.removeChild(messages[0]);
    }
}

// Handle errors
function handleError(error) {
    console.error('LiveKit error:', error);
    updateStatus('error', 'Error: ' + error.message);
}

// Toggle mute - expose to window for button onclick
window.toggleMute = function() {
    if (!room || !room.localParticipant) return;
    
    isMuted = !isMuted;
    room.localParticipant.setMicrophoneEnabled(!isMuted);
    
    const muteBtn = document.getElementById('muteBtn');
    const micIcon = muteBtn.querySelector('svg');
    
    if (isMuted) {
        muteBtn.classList.add('bg-brand-salmon');
        muteBtn.classList.remove('bg-dark-elevated');
        updateMicStatus('Microphone: Muted');
        // Update icon to muted
        micIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15L2 18.586V6a2 2 0 012-2h11a2 2 0 012 2v5M19 11v5a2 2 0 01-2 2h-7m-5 0h-.01"></path>';
    } else {
        muteBtn.classList.remove('bg-brand-salmon');
        muteBtn.classList.add('bg-dark-elevated');
        updateMicStatus('Microphone: Active');
        // Update icon to unmuted
        micIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>';
    }
}

// Disconnect from voice - expose to window for button onclick
window.disconnectVoice = async function() {
    if (room) {
        await room.disconnect();
        room = null;
        window.livekitRoom = null;
    }
}

// Update connection status
function updateStatus(state, text) {
    const indicator = document.getElementById('statusIndicator');
    const statusText = document.getElementById('statusText');
    
    statusText.textContent = text;
    
    // Update indicator color based on state
    indicator.className = 'w-3 h-3 rounded-full ';
    switch(state) {
        case 'connecting':
            indicator.className += 'bg-yellow-500 animate-pulse';
            break;
        case 'connected':
            indicator.className += 'bg-green-500';
            break;
        case 'agent-connected':
            indicator.className += 'bg-brand-teal animate-pulse';
            break;
        case 'agent-responding':
            indicator.className += 'bg-brand-orange animate-pulse';
            break;
        case 'error':
        case 'disconnected':
            indicator.className += 'bg-red-500';
            break;
    }
}

// Update microphone status
function updateMicStatus(text) {
    document.getElementById('micStatus').textContent = text;
}

// Initialize on load
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Voice preview template loaded');
    console.log('üîç Checking LiveKit client availability...');
    
    // Function to check if LiveKit SDK is available
    function checkLiveKitSDK() {
        // Debug: Check what's actually available in window
        console.log('üîç Available global variables:', {
            LiveKitSDK: typeof window.LiveKitSDK,
            LivekitClient: typeof LivekitClient,
            LiveKit: typeof LiveKit,
            livekit: typeof livekit,
            windowLivekitClient: typeof window.LivekitClient,
            windowLiveKit: typeof window.LiveKit,
            windowLivekit: typeof window.livekit,
            livekitSDKLoaded: window.livekitSDKLoaded
        });
        
        return typeof window.LiveKitSDK !== 'undefined' ||
               typeof LivekitClient !== 'undefined' || 
               typeof LiveKit !== 'undefined' || 
               typeof livekit !== 'undefined' ||
               typeof window.LivekitClient !== 'undefined' || 
               typeof window.LiveKit !== 'undefined' || 
               typeof window.livekit !== 'undefined';
    }
    
    // Function to wait for SDK to be available
    function waitForSDK() {
        if (checkLiveKitSDK()) {
            console.log('‚úÖ LiveKit client found');
            initializeLiveKit();
        } else if (window.livekitSDKLoaded === false) {
            console.error('‚ùå LiveKit SDK failed to load');
            updateStatus('error', 'LiveKit SDK failed to load');
        } else {
            console.log('üîÑ Waiting for LiveKit SDK to load...');
            setTimeout(waitForSDK, 100); // Check every 100ms
        }
    }
    
    // Debug: Check if script tag is present
    const scriptTags = document.querySelectorAll('script[src*="livekit"]');
    console.log('üîç LiveKit script tags found:', scriptTags.length);
    scriptTags.forEach((tag, index) => {
        console.log(`Script ${index}:`, tag.src);
    });
    
    // Start checking for SDK availability
    waitForSDK();
});

// Close the IIFE
})();

// Cleanup on page unload - needs to be outside IIFE to access window.livekitRoom
window.addEventListener('beforeunload', function() {
    if (window.livekitRoom) {
        window.livekitRoom.disconnect();
    }
});
</script>