{% extends "admin/base.html" %}

{% block title %}Knowledge Base - Autonomite Admin{% endblock %}

{% block extra_head %}
<!-- File upload styling -->
<style>
.upload-area {
    border: 2px dashed #2a2a2a;
    border-radius: 8px;
    padding: 40px;
    text-align: center;
    background: #1a1a1a;
    transition: all 0.3s ease;
}

.upload-area:hover {
    border-color: #01a4a6;
    background: #252525;
}

.upload-area.drag-over {
    border-color: #01a4a6;
    background: #252525;
    transform: scale(1.02);
}

.file-input {
    display: none;
}

.upload-icon {
    font-size: 48px;
    color: #01a4a6;
    margin-bottom: 16px;
}

.file-list {
    margin-top: 20px;
}

.files-container {
    max-height: 400px;
    overflow-y: auto;
    padding-right: 8px;
}

/* Custom scrollbar for files container */
.files-container::-webkit-scrollbar {
    width: 8px;
}

.files-container::-webkit-scrollbar-track {
    background: #1a1a1a;
    border-radius: 4px;
}

.files-container::-webkit-scrollbar-thumb {
    background: #2a2a2a;
    border-radius: 4px;
}

.files-container::-webkit-scrollbar-thumb:hover {
    background: #3a3a3a;
}

.file-item {
    display: flex;
    align-items: center;
    justify-content: between;
    padding: 12px;
    background: #252525;
    border: 1px solid #2a2a2a;
    border-radius: 6px;
    margin-bottom: 8px;
}

.file-info {
    flex: 1;
}

.file-name {
    font-weight: 500;
    color: #e0e0e0;
}

.file-size {
    font-size: 12px;
    color: #a0a0a0;
}

.file-remove {
    color: #f56453;
    cursor: pointer;
    font-size: 18px;
}

.file-remove:hover {
    color: #ff6b5a;
}

.progress-bar {
    width: 100%;
    height: 8px;
    background: #2a2a2a;
    border-radius: 4px;
    overflow: hidden;
    margin: 8px 0;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #01a4a6, #fc7244);
    width: 0%;
    transition: width 0.3s ease;
}

.status-badge {
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
}

.status-processing {
    background: #fc7244;
    color: white;
}

.status-ready {
    background: #01a4a6;
    color: white;
}

.status-error {
    background: #f56453;
    color: white;
}

.agent-selection {
    background: #252525;
    border: 1px solid #2a2a2a;
    border-radius: 6px;
    padding: 16px;
    margin: 16px 0;
}

.agent-checkbox {
    display: flex;
    align-items: center;
    margin: 8px 0;
}

.agent-checkbox input {
    margin-right: 8px;
}

.document-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

.document-card {
    background: #252525;
    border: 1px solid #2a2a2a;
    border-radius: 8px;
    padding: 20px;
    transition: all 0.3s ease;
    min-height: 200px;
    display: flex;
    flex-direction: column;
}

.document-card:hover {
    border-color: #01a4a6;
    transform: translateY(-2px);
}

.document-title {
    font-size: 16px;
    font-weight: 600;
    color: #e0e0e0;
    margin-bottom: 8px;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    line-height: 1.4;
    max-height: 2.8em;
}

.document-meta {
    font-size: 12px;
    color: #a0a0a0;
    margin-bottom: 12px;
    flex-grow: 1;
}

.document-actions {
    display: flex;
    gap: 8px;
    margin-top: auto;
    padding-top: 16px;
}

.btn-small {
    padding: 6px 12px;
    font-size: 12px;
}

/* Global processing banner */
#processing-banner {
    display: none;
    width: 100%;
    background: linear-gradient(90deg, rgba(1,164,166,0.12), rgba(252,114,68,0.12));
    border-top: 1px solid #2a2a2a;
    border-bottom: 1px solid #2a2a2a;
    padding: 14px 18px 18px 18px;
    box-sizing: border-box;
}

#processing-banner .banner-content {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    flex-wrap: wrap;
}

#processing-banner .badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
    border-radius: 12px;
    background: #1f1f1f;
    border: 1px solid #2a2a2a;
    font-weight: 600;
    font-size: 13px;
}

#processing-banner .banner-progress {
    flex: 1;
    min-width: 220px;
}

#processing-banner .banner-progress .progress-bar {
    height: 8px;
    margin: 6px 0 4px 0;
}
</style>
{% endblock %}

{% block content %}
<div class="container mx-auto px-4">
    <!-- Page Header + Upload -->
    <div class="mb-6 bg-dark-surface rounded-lg border border-dark-border">
        <div class="border-b border-dark-border px-6 py-4 flex flex-col gap-2">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-2xl font-bold text-dark-text">Knowledge Base</h1>
                    <p class="text-dark-text-secondary">Upload and manage documents for AI agent training</p>
                </div>
            </div>
        </div>
        <div id="processing-banner">
            <div class="banner-content text-sm text-dark-text h-full">
                <div class="flex items-center gap-2">
                    <i class="fas fa-spinner fa-spin text-brand-orange"></i>
                    <span id="processing-banner-text" class="font-semibold">Documents are processing…</span>
                </div>
                <div class="flex items-center gap-2">
                    <span class="badge text-brand-orange"><span class="w-2 h-2 rounded-full bg-brand-orange inline-block"></span><span id="banner-processing-count">0</span> processing</span>
                    <span class="badge text-brand-teal"><span class="w-2 h-2 rounded-full bg-brand-teal inline-block"></span><span id="banner-ready-count">0</span> ready</span>
                    <span class="badge text-brand-salmon"><span class="w-2 h-2 rounded-full bg-brand-salmon inline-block"></span><span id="banner-error-count">0</span> failed</span>
                    <span class="badge text-brand-orange/80"><span class="w-2 h-2 rounded-full bg-brand-orange inline-block"></span><span id="banner-pending-embeddings">0</span> pending embeddings</span>
                    <button id="view-queue-btn" class="btn-secondary px-3 py-1 text-xs rounded whitespace-nowrap" onclick="kbManager.viewQueue()">
                        <i class="fas fa-tasks mr-1"></i>View Queue
                    </button>
                </div>
                <div class="banner-progress">
                    <div class="progress-bar">
                        <div id="banner-progress-fill" class="progress-fill"></div>
                    </div>
                    <div id="banner-progress-text" class="text-xs text-dark-text-secondary">Progress —</div>
                </div>
            </div>
        </div>
        <div class="border-b border-dark-border px-6 py-4">
            <div class="flex items-center justify-between flex-wrap gap-3">
                <div>
                    <h2 class="text-lg font-semibold text-dark-text">Upload Documents</h2>
                    <p class="text-sm text-dark-text-secondary">Supported formats: {{ supported_formats }} ({{ max_upload_size_mb }}MB max per file)</p>
                    <div id="doc-summary" class="mt-2 flex flex-wrap gap-4 text-sm text-dark-text-secondary">
                        <div>Documents: <span id="doc-count" class="font-semibold text-dark-text">0</span></div>
                        <div>Total Size: <span id="doc-total-size" class="font-semibold text-dark-text">0 Bytes</span></div>
                    </div>
                </div>
                <div class="flex flex-col gap-2 items-end w-full md:w-auto">
                    <div class="flex items-center gap-4 text-sm text-dark-text-secondary">
                        <span class="flex items-center gap-1"><span class="w-2 h-2 rounded-full bg-brand-orange"></span><span id="status-processing">— processing</span></span>
                        <span class="flex items-center gap-1"><span class="w-2 h-2 rounded-full bg-brand-teal"></span><span id="status-ready">— ready</span></span>
                        <span class="flex items-center gap-1"><span class="w-2 h-2 rounded-full bg-brand-salmon"></span><span id="status-error">— failed</span></span>
                    </div>
                    <div class="flex items-center gap-3 w-full md:w-auto">
                        <button id="retry-errors-btn" class="btn-secondary px-4 py-2 rounded text-sm font-medium transition-all">
                            <i class="fas fa-redo mr-2"></i>Retry Failed
                        </button>
                    </div>
                    <div id="retry-progress" class="w-full md:w-72" style="display:none;">
                        <div class="progress-bar">
                            <div id="retry-progress-fill" class="progress-fill"></div>
                        </div>
                        <p id="retry-progress-text" class="text-xs text-dark-text-secondary mt-1">Retrying failed documents...</p>
                    </div>
                </div>
            </div>
        </div>
        <div class="p-6">
            <!-- Client Selection (for admins with multiple client access) -->
            <div id="client-selection" class="mb-6" style="display: none;">
                <label for="client-select" class="block text-sm font-medium text-dark-text mb-2">Select Client</label>
                <select id="client-select" class="w-full bg-dark-elevated border border-dark-border text-dark-text rounded px-4 py-2">
                    <!-- Clients will be loaded here -->
                </select>
            </div>
            
            <!-- Agent Selection (appears after client selection) -->
            <div id="agent-selection" class="mb-6 overflow-hidden transition-all duration-500 ease-in-out" style="max-height: 0; opacity: 0;">
                <h4 class="text-md font-medium text-dark-text mb-3">Grant Access to Sidekicks <span class="text-red-400">*</span></h4>
                <p class="text-xs text-dark-text-secondary mb-3">Select which Sidekick(s) can access these documents</p>
                <div class="mb-4">
                    <div class="agent-checkbox">
                        <input type="checkbox" id="all-agents" value="all">
                        <label for="all-agents" class="text-dark-text font-medium">All Sidekicks (Current and Future)</label>
                    </div>
                    <p class="text-xs text-dark-text-secondary mt-1 ml-6">Documents will be available to all existing agents and any new agents created in the future</p>
                </div>
                <div id="specific-agents">
                    <p class="text-sm text-dark-text-secondary mb-2">Or select specific agents:</p>
                    <div id="agents-list" class="max-h-48 overflow-y-auto space-y-2">
                        <!-- Agents will be loaded here dynamically -->
                    </div>
                </div>
            </div>
            
            <!-- Upload Mode Toggle -->
            <div class="flex border-b border-dark-border mb-6">
                <button id="upload-mode-file" class="px-6 py-3 text-sm font-medium border-b-2 border-brand-teal text-brand-teal transition-all">
                    <i class="fas fa-file-upload mr-2"></i>Upload Files
                </button>
                <button id="upload-mode-url" class="px-6 py-3 text-sm font-medium border-b-2 border-transparent text-dark-text-secondary hover:text-dark-text transition-all">
                    <i class="fas fa-globe mr-2"></i>Add Website
                </button>
            </div>

            <!-- Drag & Drop Upload Area (File Mode) -->
            <div id="upload-area" class="upload-area">
                <div class="upload-icon">
                    <i class="fas fa-cloud-upload-alt"></i>
                </div>
                <h3 class="text-lg font-medium text-dark-text mb-2">Drop files here or click to browse</h3>
                <p class="text-sm text-dark-text-secondary mb-4">You can upload multiple files at once</p>
                <input type="file" id="file-input" class="file-input" multiple accept=".pdf,.doc,.docx,.txt,.md,.srt">
                <button id="browse-btn" class="btn-primary px-6 py-2 rounded transition-all">
                    Choose Files
                </button>
            </div>

            <!-- URL Upload Area (URL Mode) -->
            <div id="url-upload-area" class="upload-area" style="display: none;">
                <div class="upload-icon">
                    <i class="fas fa-globe"></i>
                </div>
                <h3 class="text-lg font-medium text-dark-text mb-2">Add Website Content</h3>
                <p class="text-sm text-dark-text-secondary mb-4">Scrape a website and add it to your knowledge base</p>

                <div class="max-w-xl mx-auto text-left">
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-dark-text mb-2">Website URL <span class="text-brand-salmon">*</span></label>
                        <input type="url" id="url-input"
                               class="w-full bg-dark-elevated border border-dark-border text-dark-text rounded px-4 py-3 focus:border-brand-teal focus:outline-none transition-all"
                               placeholder="https://example.com/page">
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-dark-text mb-2">Title (optional)</label>
                        <input type="text" id="url-title"
                               class="w-full bg-dark-elevated border border-dark-border text-dark-text rounded px-4 py-3 focus:border-brand-teal focus:outline-none transition-all"
                               placeholder="Page title (auto-detected if empty)">
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-dark-text mb-2">Description (optional)</label>
                        <textarea id="url-description" rows="2"
                                  class="w-full bg-dark-elevated border border-dark-border text-dark-text rounded px-4 py-3 focus:border-brand-teal focus:outline-none transition-all resize-none"
                                  placeholder="Brief description of this content"></textarea>
                    </div>

                    <div class="mb-6 p-4 bg-dark-elevated rounded-lg border border-dark-border">
                        <div class="flex items-center justify-between mb-3">
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="url-crawl" class="w-4 h-4 rounded border-dark-border text-brand-teal focus:ring-brand-teal">
                                <label for="url-crawl" class="text-sm font-medium text-dark-text">Crawl multiple pages</label>
                            </div>
                        </div>
                        <p class="text-xs text-dark-text-secondary mb-3">When enabled, follows links within the same domain to scrape multiple pages</p>

                        <div id="crawl-options" class="hidden space-y-4">
                            <div>
                                <label class="block text-sm text-dark-text-secondary mb-2">Max pages to crawl</label>
                                <input type="number" id="url-crawl-limit" value="20" min="1" max="100"
                                       class="w-24 bg-dark-surface border border-dark-border text-dark-text rounded px-3 py-2 focus:border-brand-teal focus:outline-none transition-all">
                                <span class="text-xs text-dark-text-secondary ml-2">(max 100)</span>
                            </div>

                            <div>
                                <label class="block text-sm text-dark-text-secondary mb-2">Exclude paths (optional)</label>
                                <input type="text" id="url-exclude-paths"
                                       class="w-full bg-dark-surface border border-dark-border text-dark-text rounded px-3 py-2 focus:border-brand-teal focus:outline-none transition-all"
                                       placeholder="/tag/*, /author/*, /category/*, /page/*">
                                <p class="text-xs text-dark-text-secondary mt-1">Comma-separated glob patterns to skip (e.g., archive pages)</p>
                            </div>

                            <div>
                                <label class="block text-sm text-dark-text-secondary mb-2">Include paths only (optional)</label>
                                <input type="text" id="url-include-paths"
                                       class="w-full bg-dark-surface border border-dark-border text-dark-text rounded px-3 py-2 focus:border-brand-teal focus:outline-none transition-all"
                                       placeholder="/blog/*, /articles/*">
                                <p class="text-xs text-dark-text-secondary mt-1">If set, only crawl URLs matching these patterns</p>
                            </div>
                        </div>
                    </div>

                    <button id="scrape-url-btn" class="btn-primary w-full px-6 py-3 rounded transition-all flex items-center justify-center gap-2">
                        <i class="fas fa-download"></i>
                        <span>Scrape & Add to Knowledge Base</span>
                    </button>
                </div>
            </div>

            <!-- URL Scraping Progress -->
            <div id="url-scrape-progress" class="mt-6" style="display: none;">
                <h4 class="text-md font-medium text-dark-text mb-3">
                    <i class="fas fa-spider mr-2 text-brand-teal"></i>Scraping Website...
                </h4>
                <div class="progress-bar">
                    <div id="scrape-progress-fill" class="progress-fill"></div>
                </div>
                <p id="scrape-progress-text" class="text-sm text-dark-text-secondary mt-2">Connecting to website...</p>
            </div>

            <!-- Selected Files List -->
            <div id="file-list" class="file-list" style="display: none;">
                <h4 class="text-md font-medium text-dark-text mb-3">Selected Files</h4>
                <div id="files-container" class="files-container"></div>
            </div>


            <!-- Upload Controls -->
            <div id="upload-controls" class="flex gap-3 mt-6" style="display: none;">
                <button id="upload-btn" class="btn-primary px-6 py-2 rounded transition-all">
                    <i class="fas fa-upload mr-2"></i>Upload Documents
                </button>
                <button id="clear-btn" class="btn-secondary px-6 py-2 rounded transition-all">
                    <i class="fas fa-trash mr-2"></i>Clear All
                </button>
            </div>

            <!-- Upload Progress -->
            <div id="upload-progress" class="mt-6" style="display: none;">
                <h4 class="text-md font-medium text-dark-text mb-3">Upload Progress</h4>
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill"></div>
                </div>
                <p id="progress-text" class="text-sm text-dark-text-secondary mt-2">Preparing upload...</p>
            </div>
        </div>
    </div>

    <!-- Documents List -->
    <div class="bg-dark-surface rounded-lg border border-dark-border">
        <div class="border-b border-dark-border px-6 py-4">
            <div class="flex items-center justify-between">
                <h2 class="text-lg font-semibold text-dark-text">Uploaded Documents</h2>
                <div class="flex gap-2">
                    <select id="status-filter" class="bg-dark-elevated border-dark-border text-dark-text rounded px-3 py-1 text-sm">
                        <option value="">All Status</option>
                        <option value="processing">Processing</option>
                        <option value="ready">Ready</option>
                        <option value="error">Error</option>
                    </select>
                    <button id="filter-btn" class="btn-secondary px-3 py-1 text-sm rounded">
                        <i class="fas fa-filter"></i>
                    </button>
                </div>
            </div>
        </div>
        <div class="p-6">
            <div id="documents-container" class="document-grid">
                <!-- Documents will be loaded here -->
            </div>
            <div id="documents-loading" class="text-center py-8">
                <i class="fas fa-spinner fa-spin text-brand-teal text-2xl mb-2"></i>
                <p class="text-dark-text-secondary">Loading documents...</p>
            </div>
            <div id="documents-empty" class="text-center py-8" style="display: none;">
                <i class="fas fa-file-alt text-dark-text-secondary text-4xl mb-4"></i>
                <h3 class="text-lg font-medium text-dark-text mb-2">No Documents Yet</h3>
                <p class="text-dark-text-secondary">Upload your first document to get started</p>
            </div>
            <div id="pagination-controls" class="flex items-center justify-between mt-6 text-sm text-dark-text-secondary" style="display:none;">
                <div id="pagination-summary">Page 1</div>
                <div class="flex items-center gap-2">
                    <button id="prev-page" class="btn-secondary px-3 py-1 rounded text-xs" disabled>
                        <i class="fas fa-chevron-left mr-1"></i>Prev
                    </button>
                    <span id="page-display" class="text-dark-text font-semibold">1 / 1</span>
                    <button id="next-page" class="btn-secondary px-3 py-1 rounded text-xs" disabled>
                        Next<i class="fas fa-chevron-right ml-1"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="delete-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50" style="display: none;">
    <div class="flex items-center justify-center min-h-screen p-4">
        <div class="bg-dark-surface rounded-lg border border-dark-border p-6 max-w-md w-full">
            <h3 class="text-lg font-semibold text-dark-text mb-4">Delete Document</h3>
            <p class="text-dark-text-secondary mb-6">Are you sure you want to delete this document? This action cannot be undone.</p>
            <div class="flex gap-3 justify-end">
                <button id="cancel-delete" class="btn-secondary px-4 py-2 rounded">Cancel</button>
                <button id="confirm-delete" class="bg-brand-salmon hover:bg-brand-salmon/80 text-white px-4 py-2 rounded transition-all">Delete</button>
            </div>
        </div>
    </div>
</div>

<!-- Access Management Modal -->
<div id="access-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50" style="display: none;">
    <div class="flex items-center justify-center min-h-screen p-4">
        <div class="bg-dark-surface rounded-lg border border-dark-border p-6 max-w-md w-full">
            <h3 class="text-lg font-semibold text-dark-text mb-4">Manage Document Access</h3>
            <div id="access-modal-content">
                <div class="mb-4">
                    <div class="agent-checkbox">
                        <input type="checkbox" id="modal-all-agents" value="all">
                        <label for="modal-all-agents" class="text-dark-text font-medium">All Sidekicks (Current and Future)</label>
                    </div>
                </div>
                <div id="modal-specific-agents">
                    <p class="text-sm text-dark-text-secondary mb-2">Or select specific agents:</p>
                    <div id="modal-agents-list" class="max-h-48 overflow-y-auto">
                        <!-- Agent checkboxes will be loaded here -->
                    </div>
                </div>
            </div>
            <div class="flex gap-3 justify-end mt-6">
                <button id="cancel-access" class="btn-secondary px-4 py-2 rounded">Cancel</button>
                <button id="save-access" class="btn-primary px-4 py-2 rounded">Save Changes</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
window.KnowledgeBaseConfig = {
    maxUploadBytes: {{ max_upload_size_mb * 1024 * 1024 }},
    maxUploadLabel: "{{ max_upload_size_mb }}MB"
};
</script>
<script>
// Cache bust: {{ cache_bust }} - v7
class KnowledgeBaseManager {
    constructor() {
        this.selectedFiles = [];
        this.agents = [];
        this.clients = [];
        this.currentClient = null;
        this.existingFiles = new Map(); // filename (lowercase) -> doc metadata
        this.isMultiClient = false;
        this.page = 1;
        this.pageSize = 25;
        this.totalDocuments = 0;
        this.totalSize = 0;
        this.statusCounts = { processing: 0, ready: 0, error: 0 };
        this.suppressRefreshDuringRetry = false;
        this.maxUploadBytes = (window.KnowledgeBaseConfig && window.KnowledgeBaseConfig.maxUploadBytes) || ({{ max_upload_size_mb * 1024 * 1024 }});
        this.maxUploadLabel = (window.KnowledgeBaseConfig && window.KnowledgeBaseConfig.maxUploadLabel) || '{{ max_upload_size_mb }}MB';
        this.init();
    }

    async init() {
        await this.loadUserInfo();
        this.setupEventListeners();
        // Don't load agents or documents until a client is selected
        
        // Auto-refresh every 60 seconds, but only if not actively uploading AND a client is selected
        this.refreshInterval = setInterval(() => {
            // Don't refresh if user is currently uploading or if upload controls are visible
            const uploadProgress = document.getElementById('upload-progress');
            const uploadControls = document.getElementById('upload-controls');
            const isUploading = uploadProgress && uploadProgress.style.display !== 'none';
            const hasSelectedFiles = uploadControls && uploadControls.style.display !== 'none';
            
            if (!isUploading && !hasSelectedFiles && this.currentClient) {
                this.loadDocuments(true); // Silent refresh
            }
        }, 60000);
    }

    async loadUserInfo() {
        try {
            console.log('Loading user info and clients...');
            // Check if user has access to multiple clients
            const response = await fetch('/admin/api/clients', {
                credentials: 'include'
            });
            
            console.log('Clients API response status:', response.status);
            
            if (response.ok) {
                const clients = await response.json();
                console.log('Received clients:', clients);
                this.clients = Array.isArray(clients) ? clients : [];
                
                if (this.clients.length > 1) {
                    console.log('Multiple clients detected, showing client selection');
                    this.isMultiClient = true;
                    this.showClientSelection();
                    // No default - user must select from dropdown
                    this.currentClient = null;
                    this.showNotification('Please select a client from the dropdown', 'info');
                } else if (this.clients.length === 1) {
                    console.log('Single client detected:', this.clients[0]);
                    // Even with single client, require explicit selection
                    this.currentClient = null;
                    this.showNotification('Please select the client from the dropdown', 'info');
                    // Show client selection even for single client to make it clear which client is being used
                    this.showClientSelection();
                } else {
                    console.log('No clients found');
                    this.showNotification('No clients available. Please contact administrator.', 'error');
                    this.currentClient = null;
                    // Disable upload functionality when no clients
                    const uploadBtn = document.getElementById('upload-btn');
                    if (uploadBtn) uploadBtn.disabled = true;
                }
                console.log('Current client set to:', this.currentClient);
            } else {
                console.log('Clients API failed');
                this.showNotification('Failed to load clients. Please refresh the page.', 'error');
                this.currentClient = null;
                // Disable upload functionality on API failure
                const uploadBtn = document.getElementById('upload-btn');
                if (uploadBtn) uploadBtn.disabled = true;
            }
        } catch (error) {
            console.error('Failed to load user info:', error);
            // No fallback - require proper client selection
            this.currentClient = null;
            this.showNotification('Failed to load user info. Please refresh the page.', 'error');
            // Don't create fake clients - show error instead
            this.clients = [];
            const uploadBtn = document.getElementById('upload-btn');
            if (uploadBtn) uploadBtn.disabled = true;
        }
    }

    showClientSelection() {
        console.log('Showing client selection with clients:', this.clients);
        const clientSelection = document.getElementById('client-selection');
        const clientSelect = document.getElementById('client-select');
        
        if (!clientSelection) {
            console.error('Client selection element not found!');
            return;
        }
        
        clientSelection.style.display = 'block';
        clientSelect.innerHTML = '';
        
        // Add placeholder option to force selection
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = '-- Select a Client --';
        placeholder.disabled = true;
        placeholder.selected = !this.currentClient;
        clientSelect.appendChild(placeholder);
        
        this.clients.forEach(client => {
            const option = document.createElement('option');
            option.value = client.id;
            option.textContent = client.name;
            clientSelect.appendChild(option);
            console.log('Added client option:', client.name, client.id);
        });
        
        // Set the current selection if available
        if (this.currentClient) {
            clientSelect.value = this.currentClient;
        }
        
        clientSelect.addEventListener('change', async (e) => {
            this.currentClient = e.target.value;
            console.log('Client changed to:', this.currentClient);
            this.page = 1;
            await this.loadAgents();
            await this.loadDocuments();
        });
    }
    
    showAgentSelection() {
        console.log('Showing agent selection');
        const agentSelection = document.getElementById('agent-selection');
        if (!agentSelection) {
            console.error('Agent selection element not found!');
            return;
        }
        
        // Animate in with max-height and opacity
        agentSelection.style.maxHeight = '500px';
        agentSelection.style.opacity = '1';
    }
    
    hideAgentSelection() {
        console.log('Hiding agent selection');
        const agentSelection = document.getElementById('agent-selection');
        if (!agentSelection) return;
        
        // Animate out
        agentSelection.style.maxHeight = '0';
        agentSelection.style.opacity = '0';
    }

    setupEventListeners() {
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('file-input');
        const browseBtn = document.getElementById('browse-btn');
        const uploadBtn = document.getElementById('upload-btn');
        const clearBtn = document.getElementById('clear-btn');
        const refreshBtn = document.getElementById('refresh-btn');
        const filterBtn = document.getElementById('filter-btn');
        const prevPageBtn = document.getElementById('prev-page');
        const nextPageBtn = document.getElementById('next-page');
        const retryErrorsBtn = document.getElementById('retry-errors-btn');

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            this.handleFiles(e.dataTransfer.files);
        });

        // File input
        browseBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => this.handleFiles(e.target.files));

        // Upload controls
        uploadBtn.addEventListener('click', () => this.uploadFiles());
        clearBtn.addEventListener('click', () => this.clearFiles());
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => this.loadDocuments());
        }
        if (filterBtn) {
            filterBtn.addEventListener('click', () => {
                this.page = 1;
                this.loadDocuments();
            });
        }
        if (retryErrorsBtn) {
            retryErrorsBtn.addEventListener('click', () => this.retryFailedDocuments());
        }

        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', () => {
                if (this.page > 1) {
                    this.page -= 1;
                    this.loadDocuments();
                }
            });
        }

        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', () => {
                this.page += 1;
                this.loadDocuments();
            });
        }

        // Agent selection
        document.getElementById('all-agents').addEventListener('change', (e) => {
            const specificAgents = document.querySelectorAll('#specific-agents input[type="checkbox"]');
            specificAgents.forEach(cb => {
                cb.disabled = e.target.checked;
                if (e.target.checked) cb.checked = false;
            });
        });

        // Modal events
        document.getElementById('cancel-delete').addEventListener('click', () => {
            document.getElementById('delete-modal').style.display = 'none';
        });

        // Upload mode toggle (File vs URL)
        const uploadModeFile = document.getElementById('upload-mode-file');
        const uploadModeUrl = document.getElementById('upload-mode-url');
        const urlUploadArea = document.getElementById('url-upload-area');

        if (uploadModeFile && uploadModeUrl && urlUploadArea) {
            uploadModeFile.addEventListener('click', () => {
                uploadModeFile.classList.add('border-brand-teal', 'text-brand-teal');
                uploadModeFile.classList.remove('border-transparent', 'text-dark-text-secondary');
                uploadModeUrl.classList.remove('border-brand-teal', 'text-brand-teal');
                uploadModeUrl.classList.add('border-transparent', 'text-dark-text-secondary');
                uploadArea.style.display = 'block';
                urlUploadArea.style.display = 'none';
            });

            uploadModeUrl.addEventListener('click', () => {
                uploadModeUrl.classList.add('border-brand-teal', 'text-brand-teal');
                uploadModeUrl.classList.remove('border-transparent', 'text-dark-text-secondary');
                uploadModeFile.classList.remove('border-brand-teal', 'text-brand-teal');
                uploadModeFile.classList.add('border-transparent', 'text-dark-text-secondary');
                uploadArea.style.display = 'none';
                urlUploadArea.style.display = 'block';
            });
        }

        // Crawl toggle
        const urlCrawlCheckbox = document.getElementById('url-crawl');
        const crawlOptions = document.getElementById('crawl-options');
        if (urlCrawlCheckbox && crawlOptions) {
            urlCrawlCheckbox.addEventListener('change', (e) => {
                crawlOptions.classList.toggle('hidden', !e.target.checked);
            });
        }

        // URL scrape button
        const scrapeUrlBtn = document.getElementById('scrape-url-btn');
        if (scrapeUrlBtn) {
            scrapeUrlBtn.addEventListener('click', () => this.scrapeUrl());
        }
    }

    handleFiles(files) {
        const allowedTypes = ['pdf', 'doc', 'docx', 'txt', 'md', 'srt'];
        const maxSize = this.maxUploadBytes;

        Array.from(files).forEach(file => {
            const extension = file.name.split('.').pop().toLowerCase();
            
            if (!allowedTypes.includes(extension)) {
                this.showNotification(`Invalid file type: ${file.name}`, 'error');
                return;
            }

            if (file.size > maxSize) {
                this.showNotification(`File too large: ${file.name} (limit: ${this.maxUploadLabel})`, 'error');
                return;
            }

            // Check for duplicates
            if (this.selectedFiles.some(f => f.name === file.name && f.size === file.size)) {
                this.showNotification(`File already selected: ${file.name}`, 'warning');
                return;
            }

            this.selectedFiles.push({
                file: file,
                id: Date.now() + Math.random(),
                title: file.name.replace(/\.[^/.]+$/, ""), // Remove extension
                description: ""
            });
        });

        this.updateFileList();
        this.updateUI();
    }

    updateFileList() {
        const container = document.getElementById('files-container');
        container.innerHTML = '';

        this.selectedFiles.forEach((fileObj, index) => {
            const fileDiv = document.createElement('div');
            fileDiv.className = 'file-item';
            fileDiv.innerHTML = `
                <div class="file-info">
                    <div class="file-name">${fileObj.file.name}</div>
                    <div class="file-size">${this.formatFileSize(fileObj.file.size)}</div>
                    <input type="text" placeholder="Document title (optional)" 
                           class="w-full mt-2 px-2 py-1 bg-dark-elevated border border-dark-border rounded text-sm text-dark-text"
                           value="${fileObj.title}" onchange="kbManager.updateFileTitle(${index}, this.value)">
                    <textarea placeholder="Description (optional)" 
                              class="w-full mt-2 px-2 py-1 bg-dark-elevated border border-dark-border rounded text-sm text-dark-text resize-none"
                              rows="2" onchange="kbManager.updateFileDescription(${index}, this.value)">${fileObj.description}</textarea>
                </div>
                <div class="file-remove" onclick="kbManager.removeFile(${index})">
                    <i class="fas fa-times"></i>
                </div>
            `;
            container.appendChild(fileDiv);
        });
    }

    updateFileTitle(index, title) {
        if (this.selectedFiles[index]) {
            this.selectedFiles[index].title = title;
        }
    }

    updateFileDescription(index, description) {
        if (this.selectedFiles[index]) {
            this.selectedFiles[index].description = description;
        }
    }

    removeFile(index) {
        this.selectedFiles.splice(index, 1);
        this.updateFileList();
        this.updateUI();
    }

    clearFiles() {
        this.selectedFiles = [];
        document.getElementById('file-input').value = '';
        this.updateFileList();
        this.updateUI();
    }

    updateUI() {
        const hasFiles = this.selectedFiles.length > 0;
        document.getElementById('file-list').style.display = hasFiles ? 'block' : 'none';
        document.getElementById('upload-controls').style.display = hasFiles ? 'flex' : 'none';
        
        // Show agent selection if we have files
        if (hasFiles) {
            this.showAgentSelection();
            // Load agents if not already loaded
            if (this.agents.length === 0) {
                this.loadAgents();
            }
        } else {
            this.hideAgentSelection();
        }
    }

    async loadAgents() {
        // Don't load agents if no client is selected
        if (!this.currentClient) {
            console.log('No client selected, skipping agent load');
            this.agents = [];
            return;
        }
        
        try {
            // Get fresh token directly from Supabase client
            let token = null;
            try {
                if (window.__adminSupabaseClient) {
                    const { data: { session } } = await window.__adminSupabaseClient.auth.getSession();
                    if (session && session.access_token) {
                        token = session.access_token;
                        localStorage.setItem('admin_token', token);
                    }
                }
            } catch (e) {
                console.warn('[loadAgents] Session refresh failed:', e);
            }
            if (!token) {
                token = localStorage.getItem('admin_token');
            }
            const headers = {
                'Content-Type': 'application/json'
            };

            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }

            const response = await fetch(`/admin/knowledge-base/agents?client_id=${this.currentClient}`, {
                headers: headers
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const agents = await response.json();
            this.agents = Array.isArray(agents) ? agents : [];
            this.updateAgentsList();
            
            // Show agent selection after loading agents
            if (this.agents.length > 0) {
                this.showAgentSelection();
            } else {
                this.hideAgentSelection();
            }
        } catch (error) {
            console.error('Failed to load agents:', error);
            this.agents = [];
            this.updateAgentsList();
        }
    }

    updateAgentsList() {
        const container = document.getElementById('agents-list');
        container.innerHTML = '';

        if (!Array.isArray(this.agents)) {
            console.warn('Agents is not an array:', this.agents);
            this.agents = [];
            this.showNotification('Failed to load agents - using empty list', 'warning');
        }

        this.agents.forEach(agent => {
            const agentDiv = document.createElement('div');
            agentDiv.className = 'agent-checkbox';
            agentDiv.innerHTML = `
                <input type="checkbox" id="agent-${agent.id}" value="${agent.id}">
                <label for="agent-${agent.id}" class="text-dark-text">${agent.agent_name || agent.name} (${agent.agent_slug || agent.slug})</label>
            `;
            container.appendChild(agentDiv);
        });

        // Add event listeners
        const specificCheckboxes = container.querySelectorAll('input[type="checkbox"]');
        specificCheckboxes.forEach(cb => {
            cb.addEventListener('change', () => {
                if (cb.checked) {
                    document.getElementById('all-agents').checked = false;
                }
            });
        });
    }

    async uploadFiles() {
        if (this.selectedFiles.length === 0) return;
        
        // Validate client selection
        if (!this.currentClient) {
            this.showNotification('Please select a client before uploading documents', 'error');
            return;
        }

        const uploadProgress = document.getElementById('upload-progress');
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');
        
        uploadProgress.style.display = 'block';
        document.getElementById('upload-btn').disabled = true;

        try {
            // Get selected agents
            const allAgents = document.getElementById('all-agents').checked;
            let selectedAgents = [];

            if (!allAgents) {
                const specificCheckboxes = document.querySelectorAll('#specific-agents input[type="checkbox"]:checked');
                selectedAgents = Array.from(specificCheckboxes).map(cb => cb.value);
            }

            // Validate that at least one agent is selected
            if (!allAgents && selectedAgents.length === 0) {
                this.showNotification('Please select at least one Sidekick to grant access to these documents', 'error');
                uploadProgress.style.display = 'none';
                document.getElementById('upload-btn').disabled = false;
                return;
            }

            const totalFiles = this.selectedFiles.length;
            let completed = 0;
            let skipped = 0;

            for (let i = 0; i < this.selectedFiles.length; i++) {
                const fileObj = this.selectedFiles[i];
                const fileName = fileObj.file.name;
                progressText.textContent = `Uploading ${fileObj.file.name} (${i + 1}/${totalFiles})...`;

                // Duplicate detection by filename
                const existing = this.existingFiles.get(fileName.toLowerCase());
                let replaceExisting = false;
                if (existing) {
                    const wantReplace = confirm(`"${fileName}" already exists. Click OK to update it, or Cancel to skip this file.`);
                    if (!wantReplace) {
                        skipped++;
                        continue;
                    }
                    replaceExisting = true;
                }

                const formData = new FormData();
                formData.append('file', fileObj.file);
                formData.append('title', fileObj.title || fileObj.file.name);
                formData.append('description', fileObj.description || '');
                formData.append('client_id', this.currentClient);
                formData.append('replace_existing', replaceExisting ? 'true' : 'false');

                if (allAgents) {
                    formData.append('agent_ids', 'all');
                } else {
                    formData.append('agent_ids', selectedAgents.join(','));
                }

                // Get fresh token for upload
                let token = null;
                if (window.refreshAdminToken) {
                    token = await window.refreshAdminToken();
                }
                if (!token) {
                    token = localStorage.getItem('admin_token');
                }

                const headers = {};
                if (token) {
                    headers['Authorization'] = `Bearer ${token}`;
                }

                const response = await fetch('/admin/knowledge-base/upload', {
                    method: 'POST',
                    headers: headers,
                    body: formData
                });

                const result = await response.json();
                
                if (!result.success) {
                    this.showNotification(`Failed to upload ${fileObj.file.name}: ${result.message}`, 'error');
                } else {
                    completed++;
                    this.existingFiles.set(fileName.toLowerCase(), { id: result.document_id, status: result.status });
                }

                // Update progress
                const progress = ((i + 1) / totalFiles) * 100;
                progressFill.style.width = `${progress}%`;
            }

            progressText.textContent = `Upload complete! ${completed}/${totalFiles} files uploaded successfully${skipped ? `, ${skipped} skipped.` : '.'}`;
            
            if (completed > 0) {
                this.showNotification(`Successfully uploaded ${completed} documents`, 'success');
                this.clearFiles();
                this.loadDocuments();
            }

        } catch (error) {
            this.showNotification('Upload failed: ' + error.message, 'error');
        } finally {
            document.getElementById('upload-btn').disabled = false;
            setTimeout(() => {
                uploadProgress.style.display = 'none';
                progressFill.style.width = '0%';
            }, 3000);
        }
    }

    async scrapeUrl() {
        // Validate client selection
        if (!this.currentClient) {
            this.showNotification('Please select a client before adding website content', 'error');
            return;
        }

        const urlInput = document.getElementById('url-input');
        const titleInput = document.getElementById('url-title');
        const descInput = document.getElementById('url-description');
        const crawlCheckbox = document.getElementById('url-crawl');
        const crawlLimitInput = document.getElementById('url-crawl-limit');
        const scrapeBtn = document.getElementById('scrape-url-btn');
        const scrapeProgress = document.getElementById('url-scrape-progress');
        const scrapeProgressFill = document.getElementById('scrape-progress-fill');
        const scrapeProgressText = document.getElementById('scrape-progress-text');

        const url = urlInput.value.trim();
        if (!url) {
            this.showNotification('Please enter a URL', 'error');
            urlInput.focus();
            return;
        }

        // Basic URL validation
        try {
            new URL(url.startsWith('http') ? url : `https://${url}`);
        } catch (e) {
            this.showNotification('Please enter a valid URL', 'error');
            urlInput.focus();
            return;
        }

        const title = titleInput.value.trim();
        const description = descInput.value.trim();
        const crawl = crawlCheckbox.checked;
        const crawlLimit = parseInt(crawlLimitInput.value) || 20;

        // Get path filters
        const excludePathsInput = document.getElementById('url-exclude-paths');
        const includePathsInput = document.getElementById('url-include-paths');
        const excludePaths = excludePathsInput ? excludePathsInput.value.trim() : '';
        const includePaths = includePathsInput ? includePathsInput.value.trim() : '';

        // Get selected agents
        const allAgents = document.getElementById('all-agents').checked;
        let agentIds = '';
        if (allAgents) {
            agentIds = 'all';
        } else {
            const specificCheckboxes = document.querySelectorAll('#specific-agents input[type="checkbox"]:checked');
            agentIds = Array.from(specificCheckboxes).map(cb => cb.value).join(',');
        }

        // Validate that at least one agent is selected
        if (!allAgents && !agentIds) {
            this.showNotification('Please select at least one Sidekick to grant access to these documents', 'error');
            return;
        }

        // Show progress
        scrapeBtn.disabled = true;
        scrapeBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Scraping...';
        scrapeProgress.style.display = 'block';
        scrapeProgressFill.style.width = '0%';
        scrapeProgressText.textContent = crawl ? 'Starting crawl...' : 'Scraping page...';

        try {
            // Get auth token
            let token = null;
            if (window.refreshAdminToken) {
                token = await window.refreshAdminToken();
            }
            if (!token) {
                token = localStorage.getItem('admin_token');
            }

            const headers = {
                'Content-Type': 'application/json'
            };
            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }

            // Animate progress while waiting
            let progressInterval = setInterval(() => {
                const currentWidth = parseFloat(scrapeProgressFill.style.width) || 0;
                if (currentWidth < 90) {
                    scrapeProgressFill.style.width = `${currentWidth + 5}%`;
                }
            }, 500);

            const response = await fetch('/admin/knowledge-base/upload-url', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    url: url,
                    title: title,
                    description: description,
                    client_id: this.currentClient,
                    agent_ids: agentIds,
                    crawl: crawl,
                    crawl_limit: crawlLimit,
                    exclude_paths: excludePaths,
                    include_paths: includePaths
                })
            });

            clearInterval(progressInterval);
            scrapeProgressFill.style.width = '100%';

            const result = await response.json();

            if (result.success) {
                const pageCount = result.total_pages || 1;
                const message = pageCount > 1
                    ? `Successfully queued ${result.successful} page(s) for processing`
                    : 'Website content queued for processing';
                this.showNotification(message, 'success');

                // Clear form
                urlInput.value = '';
                titleInput.value = '';
                descInput.value = '';
                crawlCheckbox.checked = false;
                document.getElementById('crawl-options').classList.add('hidden');

                // Refresh documents list
                setTimeout(() => this.loadDocuments(), 1000);

                scrapeProgressText.textContent = message;
            } else {
                this.showNotification(result.message || 'Failed to scrape URL', 'error');
                scrapeProgressText.textContent = result.message || 'Scraping failed';
            }

        } catch (error) {
            console.error('Scrape error:', error);
            this.showNotification('Failed to scrape URL: ' + error.message, 'error');
            scrapeProgressText.textContent = 'Error: ' + error.message;
        } finally {
            scrapeBtn.disabled = false;
            scrapeBtn.innerHTML = '<i class="fas fa-download"></i><span>Scrape & Add to Knowledge Base</span>';

            setTimeout(() => {
                scrapeProgress.style.display = 'none';
                scrapeProgressFill.style.width = '0%';
            }, 3000);
        }
    }

    updateDocumentSummary(documents, totalSizeOverride = null) {
        const summaryRow = document.getElementById('doc-summary');
        const countEl = document.getElementById('doc-count');
        const sizeEl = document.getElementById('doc-total-size');

        if (!summaryRow || !countEl || !sizeEl) return;

        const docArray = Array.isArray(documents) ? documents : [];
        const totalSizeBytes = docArray.reduce((sum, doc) => {
            const size = Number(doc.file_size);
            return sum + (Number.isFinite(size) ? size : 0);
        }, 0) || 0;

        if (!this.currentClient) {
            countEl.textContent = '—';
            sizeEl.textContent = '—';
        } else {
            const effectiveSize = Number.isFinite(totalSizeOverride) ? totalSizeOverride : totalSizeBytes;
            countEl.textContent = this.totalDocuments || docArray.length;
            sizeEl.textContent = this.formatFileSize(effectiveSize);
        }

        summaryRow.style.display = 'flex';
    }

    updatePaginationControls(currentPageCount = 0) {
        const wrapper = document.getElementById('pagination-controls');
        const pageDisplay = document.getElementById('page-display');
        const summary = document.getElementById('pagination-summary');
        const prevBtn = document.getElementById('prev-page');
        const nextBtn = document.getElementById('next-page');

        if (!wrapper || !pageDisplay || !summary || !prevBtn || !nextBtn) return;

        if (!this.currentClient) {
            wrapper.style.display = 'none';
            return;
        }

        const total = this.totalDocuments || currentPageCount;
        const totalPages = Math.max(1, Math.ceil(total / this.pageSize));
        const currentPage = Math.min(this.page, totalPages);

        pageDisplay.textContent = `${currentPage} / ${totalPages}`;
        const hasTotalSize = Number.isFinite(this.totalSize);
        summary.textContent = `Total documents: ${total}${hasTotalSize ? ` • Total size: ${this.formatFileSize(this.totalSize)}` : ''}`;

        prevBtn.disabled = currentPage <= 1;
        // If we have a total count, use that to determine if next exists. Otherwise, assume there is a next page if this page is full.
        const hasMore = total ? currentPage < totalPages : currentPageCount >= this.pageSize;
        nextBtn.disabled = !hasMore;

        wrapper.style.display = 'flex';
    }

    updateProcessingBanner() {
        const banner = document.getElementById('processing-banner');
        const bannerText = document.getElementById('processing-banner-text');
        const processingCountEl = document.getElementById('banner-processing-count');
        const readyCountEl = document.getElementById('banner-ready-count');
        const errorCountEl = document.getElementById('banner-error-count');
        const progressFill = document.getElementById('banner-progress-fill');
        const progressText = document.getElementById('banner-progress-text');

        if (!banner || !bannerText || !processingCountEl || !readyCountEl || !errorCountEl || !progressFill || !progressText) {
            return;
        }

        const { processing = 0, ready = 0, error = 0, pending_embeddings = 0 } = this.statusCounts || {};
        const total = processing + ready + error + pending_embeddings;
        const completed = ready + error;
        const percent = total > 0 ? Math.round((completed / total) * 100) : 0;

        processingCountEl.textContent = processing;
        readyCountEl.textContent = ready;
        errorCountEl.textContent = error;
        progressFill.style.width = `${percent}%`;
        progressText.textContent = total > 0
            ? `Progress: ${percent}% • ${completed}/${total} done`
            : 'No documents processing';
        const pendingEl = document.getElementById('banner-pending-embeddings');
        if (pendingEl) pendingEl.textContent = pending_embeddings || 0;

        // Only show when there are processing docs; hide otherwise
        if (processing > 0 || pending_embeddings > 0) {
            const queueCount = processing + pending_embeddings;
            if (this.currentClient) {
                bannerText.textContent = `Documents are processing for this client (${queueCount} in queue)`;
            } else if (this.isMultiClient) {
                bannerText.textContent = `Documents are processing across clients (${queueCount} in queue)`;
            } else {
                bannerText.textContent = `Documents are processing (${queueCount} in queue)`;
            }
            banner.style.display = 'block';
        } else {
            banner.style.display = 'none';
        }
    }

    async updateStatusCounts() {
        const processingEl = document.getElementById('status-processing');
        const readyEl = document.getElementById('status-ready');
        const errorEl = document.getElementById('status-error');
        if (!processingEl || !readyEl || !errorEl) return;

        try {
            // Get fresh token
            let token = null;
            if (window.refreshAdminToken) {
                token = await window.refreshAdminToken();
            }
            if (!token) {
                token = localStorage.getItem('admin_token');
            }
            const headers = { 'Content-Type': 'application/json' };
            if (token) headers['Authorization'] = `Bearer ${token}`;

            // If superadmin without a selected client, aggregate across all clients in view
            if (!this.currentClient && this.isMultiClient && Array.isArray(this.clients) && this.clients.length > 0) {
                let agg = { processing: 0, ready: 0, error: 0, pending_embeddings: 0 };
                for (const client of this.clients) {
                    if (!client || !client.id) continue;
                    const resp = await fetch(`/admin/knowledge-base/document-stats?client_id=${client.id}`, { headers });
                    if (!resp.ok) continue;
                    const stats = await resp.json();
                    agg.processing += Number(stats.processing) || 0;
                    agg.ready += Number(stats.ready) || 0;
                    agg.error += Number(stats.error) || 0;
                    agg.pending_embeddings += Number(stats.pending_embeddings) || 0;
                }
                this.statusCounts = agg;
                processingEl.textContent = `${agg.processing} processing`;
                readyEl.textContent = `${agg.ready} ready`;
                errorEl.textContent = `${agg.error} failed`;
                this.updateProcessingBanner();
                return;
            }

            if (!this.currentClient) {
                processingEl.textContent = '— processing';
                readyEl.textContent = '— ready';
                errorEl.textContent = '— failed';
                this.statusCounts = { processing: 0, ready: 0, error: 0, pending_embeddings: 0 };
                this.updateProcessingBanner();
                return;
            }

            const resp = await fetch(`/admin/knowledge-base/document-stats?client_id=${this.currentClient}`, { headers });
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const stats = await resp.json();
            const processingCount = Number(stats.processing) || 0;
            const readyCount = Number(stats.ready) || 0;
            const errorCount = Number(stats.error) || 0;
            const pendingEmbCount = Number(stats.pending_embeddings) || 0;
            this.statusCounts = { processing: processingCount, ready: readyCount, error: errorCount, pending_embeddings: pendingEmbCount };
            processingEl.textContent = `${processingCount} processing`;
            readyEl.textContent = `${readyCount} ready`;
            errorEl.textContent = `${errorCount} failed`;
            this.updateProcessingBanner();
        } catch (err) {
            console.warn('Failed to update status counts', err);
        }
    }

    async loadDocuments(silent = false) {
        const container = document.getElementById('documents-container');
        const loading = document.getElementById('documents-loading');
        const empty = document.getElementById('documents-empty');

        // Check if a client is selected
        if (!this.currentClient) {
            this.totalDocuments = 0;
            this.totalSize = 0;
            this.updateDocumentSummary([]);
            loading.style.display = 'none';
            container.style.display = 'none';
            empty.style.display = 'block';
            empty.innerHTML = `
                <i class="fas fa-building text-dark-text-secondary text-4xl mb-4"></i>
                <h3 class="text-lg font-medium text-dark-text mb-2">No Client Selected</h3>
                <p class="text-dark-text-secondary">Please select a client from the dropdown above to view documents</p>
            `;
            return;
        }

        // Only show loading indicator if not a silent refresh
        if (!silent) {
            loading.style.display = 'block';
            container.style.display = 'none';
            empty.style.display = 'none';
        }

        try {
            const statusFilter = document.getElementById('status-filter').value;
            let url = `/admin/knowledge-base/documents?client_id=${this.currentClient}&page=${this.page}&page_size=${this.pageSize}`;
            if (statusFilter) {
                url += `&status=${statusFilter}`;
            }

            // Get fresh token directly from Supabase client
            let token = null;
            try {
                if (window.__adminSupabaseClient) {
                    const { data: { session } } = await window.__adminSupabaseClient.auth.getSession();
                    if (session && session.access_token) {
                        token = session.access_token;
                        localStorage.setItem('admin_token', token);
                    }
                }
            } catch (e) {
                console.warn('[loadDocuments] Session refresh failed:', e);
            }
            if (!token) {
                token = localStorage.getItem('admin_token');
            }
            const headers = {
                'Content-Type': 'application/json'
            };

            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }

            const response = await fetch(url, {
                headers: headers
            });

            const contentType = response.headers.get('content-type') || '';
            const bodyText = await response.text();

            if (!response.ok) {
                const statusText = response.statusText || bodyText.slice(0, 160);
                throw new Error(`HTTP ${response.status}: ${statusText}`);
            }

            let documents = [];
            if (contentType.includes('application/json')) {
                try {
                    documents = JSON.parse(bodyText);
                } catch (parseError) {
                    throw new Error('Server returned invalid JSON for documents list.');
                }
            } else {
                throw new Error('Server returned an unexpected response format while loading documents.');
            }

            let documentArray = [];
            let totalCount = null;
            let totalSize = null;
            let allFileNames = [];

            if (Array.isArray(documents)) {
                documentArray = documents;
                totalCount = Number(response.headers.get('X-Total-Count')) || documents.length;
                totalSize = Number(response.headers.get('X-Total-Size'));
            } else if (documents && Array.isArray(documents.documents)) {
                documentArray = documents.documents;
                totalCount = Number(documents.total_count);
                totalSize = Number(documents.total_size);
                this.page = Number(documents.page) || this.page;
                this.pageSize = Number(documents.page_size) || this.pageSize;
                if (Array.isArray(documents.all_file_names)) {
                    allFileNames = documents.all_file_names;
                }
            }

            // Track totals for pagination/summary
            this.totalDocuments = Number.isFinite(totalCount) ? totalCount : documentArray.length;
            this.totalSize = Number.isFinite(totalSize) ? totalSize : null;

            // Cache filenames for duplicate detection
            this.existingFiles.clear();
            allFileNames.forEach(name => {
                if (typeof name === 'string') {
                    this.existingFiles.set(name.toLowerCase(), { file_name: name });
                }
            });
            documentArray.forEach(doc => {
                if (doc.file_name) {
                    this.existingFiles.set(String(doc.file_name).toLowerCase(), doc);
                }
            });

            // Update summary row with latest totals
            this.updateDocumentSummary(documentArray, this.totalSize);
            this.updatePaginationControls(documentArray.length);
            this.updateStatusCounts();

            // Only hide loading if it was shown (not silent refresh)
            if (!silent) {
                loading.style.display = 'none';
            }

            if (documentArray.length === 0) {
                if (!silent) {
                    empty.style.display = 'block';
                }
                container.style.display = 'none';
                return;
            }

            container.style.display = 'grid';
            container.innerHTML = '';

            documentArray.forEach(doc => {
                const docCard = this.createDocumentCard(doc);
                container.appendChild(docCard);
            });

        } catch (error) {
            if (!silent) {
                loading.style.display = 'none';
                this.showNotification('Failed to load documents: ' + error.message, 'error');
            }
            // For silent refresh errors, just log them without showing notifications
            else {
                console.warn('Silent document refresh failed:', error.message);
            }
        }
    }

    createDocumentCard(doc) {
        const card = document.createElement('div');
        card.className = 'document-card';
        
        const statusClass = `status-${doc.status}`;
        const fileSize = this.formatFileSize(doc.file_size);
        const uploadDate = new Date(doc.created_at).toLocaleDateString();
        const errorMessage = (doc.processing_metadata && doc.processing_metadata.error_message) ? doc.processing_metadata.error_message : '';
        
        // Determine agent access display
        let agentAccessText = '';
        if (doc.agent_access === 'all') {
            agentAccessText = '<i class="fas fa-globe text-brand-teal mr-1"></i>All Sidekicks';
        } else if (doc.agent_ids && doc.agent_ids.length > 0) {
            const agentCount = doc.agent_ids.length;
            agentAccessText = `<i class="fas fa-robot text-brand-orange mr-1"></i>${agentCount} Agent${agentCount > 1 ? 's' : ''}`;
        } else {
            agentAccessText = '<i class="fas fa-ban text-dark-text-secondary mr-1"></i>No Access';
        }

        card.innerHTML = `
            <div class="document-title">${doc.title}</div>
            <div class="document-meta">
                <div class="flex items-center gap-2 mb-1">
                    <span class="status-badge ${statusClass}">${doc.status}</span>
                    <span class="text-brand-teal text-xs">${doc.file_type.toUpperCase()}</span>
                </div>
                <div class="text-xs">
                    <div>Size: ${fileSize}</div>
                    <div>Uploaded: ${uploadDate}</div>
                    <div>Chunks: ${doc.chunk_count || 0}</div>
                    <div class="mt-1">${agentAccessText}</div>
                    ${doc.status === 'error' && errorMessage ? `<div class="text-brand-salmon mt-2">Error: ${errorMessage}</div>` : ''}
                </div>
            </div>
            <div class="document-actions">
                ${doc.status === 'processing' || doc.status === 'error' ? `
                    <button class="btn-secondary btn-small" onclick="kbManager.reprocessDocument('${doc.id}')">
                        <i class="fas fa-redo mr-1"></i>Retry
                    </button>
                ` : ''}
                <button class="btn-secondary btn-small" onclick="kbManager.manageAccess('${doc.id}', '${doc.agent_access}', '${(doc.agent_ids || []).join(',')}')">
                    <i class="fas fa-users mr-1"></i>Access
                </button>
                <button class="bg-brand-salmon hover:bg-brand-salmon/80 text-white btn-small" onclick="kbManager.deleteDocument('${doc.id}')">
                    <i class="fas fa-trash mr-1"></i>Delete
                </button>
            </div>
        `;

        return card;
    }

    async deleteDocument(documentId) {
        const modal = document.getElementById('delete-modal');
        const confirmBtn = document.getElementById('confirm-delete');
        
        modal.style.display = 'flex';
        
        confirmBtn.onclick = async () => {
            try {
                // Get fresh token
                let token = null;
                if (window.refreshAdminToken) {
                    token = await window.refreshAdminToken();
                }
                if (!token) {
                    token = localStorage.getItem('admin_token');
                }
                const headers = {
                    'Content-Type': 'application/json'
                };

                if (token) {
                    headers['Authorization'] = `Bearer ${token}`;
                }

                const response = await fetch(`/admin/knowledge-base/documents/${documentId}`, {
                    method: 'DELETE',
                    headers: headers
                });

                const result = await response.json();
                
                if (result.success) {
                    this.showNotification('Document deleted successfully', 'success');
                    this.loadDocuments();
                } else {
                    this.showNotification('Failed to delete document', 'error');
                }
            } catch (error) {
                this.showNotification('Error deleting document: ' + error.message, 'error');
            } finally {
                modal.style.display = 'none';
            }
        };
    }

    async reprocessDocument(documentId) {
        try {
            // Get fresh token
            let token = null;
            if (window.refreshAdminToken) {
                token = await window.refreshAdminToken();
            }
            if (!token) {
                token = localStorage.getItem('admin_token');
            }
            const headers = {
                'Content-Type': 'application/json'
            };

            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }

            const response = await fetch(`/admin/knowledge-base/documents/${documentId}/reprocess?client_id=${this.currentClient || ''}`, {
                method: 'POST',
                headers: headers
            });

            const result = await response.json();
            
            if (result.success) {
                this.showNotification('Document reprocessing started', 'success');
                if (!this.suppressRefreshDuringRetry) {
                    this.loadDocuments();
                }
            } else {
                this.showNotification('Failed to reprocess document', 'error');
            }
        } catch (error) {
            this.showNotification('Error reprocessing document: ' + error.message, 'error');
        }
    }

    async retryFailedDocuments() {
        if (!this.currentClient) {
            this.showNotification('Select a client first', 'warning');
            return;
        }
        this.showNotification('Retrying failed documents...', 'info');
        const progressBar = document.getElementById('retry-progress');
        const progressFill = document.getElementById('retry-progress-fill');
        const progressText = document.getElementById('retry-progress-text');
        if (progressBar) progressBar.style.display = 'block';
        if (progressFill) progressFill.style.width = '0%';
        if (progressText) progressText.textContent = 'Starting...';

        try {
            this.suppressRefreshDuringRetry = true;
            // Get fresh token
            let token = null;
            if (window.refreshAdminToken) {
                token = await window.refreshAdminToken();
            }
            if (!token) {
                token = localStorage.getItem('admin_token');
            }
            const headers = { 'Content-Type': 'application/json' };
            if (token) headers['Authorization'] = `Bearer ${token}`;

            // First fetch total error count
            const statsResp = await fetch(`/admin/knowledge-base/document-stats?client_id=${this.currentClient}`, { headers });
            let totalErrors = 0;
            if (statsResp.ok) {
                const stats = await statsResp.json();
                totalErrors = Number(stats.error) || 0;
            }

            let processed = 0;
            let page = 1;
            const pageSize = 50;

            while (true) {
                const url = `/admin/knowledge-base/documents?client_id=${this.currentClient}&status=error&page=${page}&page_size=${pageSize}`;
                const response = await fetch(url, { headers });
                if (!response.ok) break;
                const body = await response.json();
                const docs = Array.isArray(body) ? body : (body.documents || []);
                if (!docs.length) break;

                for (const doc of docs) {
                    await this.reprocessDocument(doc.id);
                    processed += 1;
                    const pct = totalErrors ? (processed / totalErrors) * 100 : (processed / (page * pageSize)) * 100;
                    if (progressFill) progressFill.style.width = `${Math.min(100, pct)}%`;
                    if (progressText) progressText.textContent = `Retried ${processed}${totalErrors ? ` / ${totalErrors}` : ''}`;
                }

                if (docs.length < pageSize) break;
                page += 1;
            }

            this.showNotification(`Retried ${processed} failed documents`, 'success');
            await this.loadDocuments();
            await this.updateStatusCounts();
        } catch (err) {
            this.showNotification('Retry failed: ' + err.message, 'error');
        } finally {
            this.suppressRefreshDuringRetry = false;
            setTimeout(() => {
                if (progressBar) progressBar.style.display = 'none';
                if (progressFill) progressFill.style.width = '0%';
                if (progressText) progressText.textContent = 'Retrying failed documents...';
            }, 2000);
        }
    }

    manageAccess(documentId, currentAccess, currentAgentIds) {
        const modal = document.getElementById('access-modal');
        const modalAllAgents = document.getElementById('modal-all-agents');
        const modalAgentsList = document.getElementById('modal-agents-list');
        const saveBtn = document.getElementById('save-access');
        const cancelBtn = document.getElementById('cancel-access');
        
        // Reset modal state
        modalAllAgents.checked = currentAccess === 'all';
        modalAgentsList.innerHTML = '';
        
        // Populate agents list
        const currentAgentIdArray = currentAgentIds ? currentAgentIds.split(',').filter(id => id) : [];
        
        this.agents.forEach(agent => {
            const agentDiv = document.createElement('div');
            agentDiv.className = 'agent-checkbox mb-2';
            const isChecked = currentAgentIdArray.includes(agent.id);
            agentDiv.innerHTML = `
                <input type="checkbox" id="modal-agent-${agent.id}" value="${agent.id}" ${isChecked ? 'checked' : ''} ${currentAccess === 'all' ? 'disabled' : ''}>
                <label for="modal-agent-${agent.id}" class="text-dark-text">${agent.agent_name || agent.name}</label>
            `;
            modalAgentsList.appendChild(agentDiv);
        });
        
        // Handle all agents checkbox
        modalAllAgents.addEventListener('change', (e) => {
            const specificCheckboxes = modalAgentsList.querySelectorAll('input[type="checkbox"]');
            specificCheckboxes.forEach(cb => {
                cb.disabled = e.target.checked;
                if (e.target.checked) cb.checked = false;
            });
        });
        
        // Handle specific agent checkboxes
        modalAgentsList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.addEventListener('change', () => {
                if (cb.checked) {
                    modalAllAgents.checked = false;
                }
            });
        });
        
        // Show modal
        modal.style.display = 'flex';
        
        // Handle save
        saveBtn.onclick = async () => {
            try {
                const allAgents = modalAllAgents.checked;
                let selectedAgents = [];
                
                if (!allAgents) {
                    const checkboxes = modalAgentsList.querySelectorAll('input[type="checkbox"]:checked');
                    selectedAgents = Array.from(checkboxes).map(cb => cb.value);
                }
                
                const response = await fetch(`/admin/knowledge-base/documents/${documentId}/access`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('admin_token')}`
                    },
                    body: JSON.stringify({
                        agent_access: allAgents ? 'all' : 'specific',
                        agent_ids: selectedAgents
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    this.showNotification('Document access updated successfully', 'success');
                    await this.loadDocuments();
                } else {
                    this.showNotification('Failed to update document access', 'error');
                }
            } catch (error) {
                this.showNotification('Error updating access: ' + error.message, 'error');
            } finally {
                modal.style.display = 'none';
            }
        };
        
        // Handle cancel
        cancelBtn.onclick = () => {
            modal.style.display = 'none';
        };
    }

    formatFileSize(bytes) {
        const value = Number(bytes) || 0;
        if (value <= 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(value) / Math.log(k));
        return parseFloat((value / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    showNotification(message, type = 'info') {
        // Create notification element
        const notification = document.createElement('div');
        notification.className = `fixed top-4 right-4 px-6 py-3 rounded-lg shadow-lg z-50 text-white`;
        
        switch (type) {
            case 'success':
                notification.style.background = '#01a4a6';
                break;
            case 'error':
                notification.style.background = '#f56453';
                break;
            case 'warning':
                notification.style.background = '#fc7244';
                break;
            default:
                notification.style.background = '#4a5568';
        }
        
        notification.textContent = message;
        document.body.appendChild(notification);
        
        // Auto remove after 3 seconds
        setTimeout(() => {
            notification.remove();
        }, 3000);
    }
    
    // Clean up resources when leaving the page
    cleanup() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
        }
    }

    viewQueue() {
        // Focus the documents list and apply a processing filter if available
        const statusFilter = document.getElementById('status-filter');
        if (statusFilter) {
            statusFilter.value = 'processing';
        }
        // Smooth scroll to documents section
        const documentsSection = document.getElementById('documents-container');
        if (documentsSection) {
            documentsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        // Reload documents with the processing filter
        this.loadDocuments();
    }
}

// Initialize when page loads
let kbManager;
document.addEventListener('DOMContentLoaded', () => {
    kbManager = new KnowledgeBaseManager();
});
</script>
{% endblock %}
