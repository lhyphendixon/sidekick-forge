<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sidekick Embed</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'brand-teal': '#01a4a6',
            'brand-orange': '#fc7244',
            'dark-bg': '#000000',
            'dark-surface': 'rgb(20, 20, 20)',
            'dark-elevated': '#252525',
            'dark-border': '#2a2a2a',
            'dark-text': '#e0e0e0',
            'dark-text-secondary': '#a0a0a0'
          }
        }
      }
    }
  </script>
  <style>
    html, body { height: 100%; }
    html { background: #000000 !important; }
    body { margin: 0; background: #000000 !important; color:#e0e0e0; height:100%; }
    * { background-color: inherit; }
    .htmx-indicator { opacity: 0; transition: opacity 300ms ease; }
    .htmx-request .htmx-indicator { opacity: 1; }
    /* Button inline loading */
    .btn-loading { position: relative; opacity: 0.9; pointer-events: none; }
    .btn-loading > * { visibility: hidden; }
    .btn-loading::after { content:""; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:16px; height:16px; border:2px solid #2a2a2a; border-top-color:#01a4a6; border-radius:9999px; animation: spin 0.9s linear infinite; }
    @keyframes spin { 0%{transform:translate(-50%,-50%) rotate(0deg);} 100%{transform:translate(-50%,-50%) rotate(360deg);} }
    /* Force black background on everything */
    body, html, .video-background-body {
      background: #000000 !important;
      background-color: #000000 !important;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.47.10/dist/umd/supabase.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/livekit-client@2/dist/livekit-client.umd.min.js"></script>
  <link rel="stylesheet" href="/static/css/citations.css">
  <link rel="stylesheet" href="/static/css/video-background.css">
  <script src="/static/js/citations.js"></script>
</head>
<body class="video-background-body">
  <!-- Video Background -->
  <video class="embed-video-background" autoplay muted loop>
    <source src="/static/videos/background2.mp4" type="video/mp4">
  </video>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const video = document.querySelector('.embed-video-background');
      if (video) {
        video.playbackRate = 0.50;
      }
    });
  </script>
  <!-- 95% Opacity Overlay -->
  <div class="embed-video-overlay"></div>
  <div class="mx-auto p-3 h-full" style="max-width: 800px;">
    <div class="bg-dark-bg border border-dark-border rounded-lg h-full flex flex-col">
      <div id="auth" class="p-4 space-y-2">
        <h3 class="text-lg text-dark-text">Sign in</h3>
        <input id="email" class="w-full bg-dark-elevated text-dark-text border border-dark-border rounded p-2" placeholder="email" />
        <input id="password" class="w-full bg-dark-elevated text-dark-text border border-dark-border rounded p-2" placeholder="password" type="password" />
        <div class="flex gap-2">
          <button class="btn-primary px-3 py-2 rounded text-sm" onclick="login()">Login</button>
          <button class="px-3 py-2 rounded text-sm border border-dark-border" onclick="signup()">Create account</button>
        </div>
        <div id="auth-msg" class="text-dark-text-secondary text-sm"></div>
      </div>
      <div id="chat" class="hidden flex-1 flex flex-col">
        <div class="p-3 border-b border-dark-border flex gap-2">
          <button id="tab-text" class="mode-btn flex-1 py-2 px-4 rounded-md text-sm font-medium bg-brand-teal text-white" onclick="switchTab('text')">Text</button>
          <button id="tab-voice" class="mode-btn flex-1 py-2 px-4 rounded-md text-sm font-medium bg-dark-elevated text-dark-text border border-dark-border" onclick="switchTab('voice')">Voice</button>
        </div>
        <div id="panel-text" class="flex-1 flex flex-col">
          <div class="flex-1 flex flex-col">
            <div id="chatMessages" class="flex-1 overflow-y-auto p-4 space-y-4">
              <div class="text-center text-dark-text-secondary text-sm py-8">
                <p>Start a conversation with your sidekick</p>
                <p class="text-xs mt-2">Messages are not saved</p>
              </div>
            </div>
            <div class="border-t border-dark-border p-3">
              <form onsubmit="return sendMsg(event)" class="flex gap-2">
                <input id="msg" name="message" placeholder="Type a message..." class="flex-1 bg-dark-elevated border-dark-border text-dark-text rounded-md px-3 py-2 border" autocomplete="off" required />
                <button type="submit" class="btn-primary px-4 py-2 rounded text-sm font-medium">Send</button>
              </form>
            </div>
          </div>
        </div>
        <div id="panel-voice" class="hidden p-4 flex-1 flex flex-col items-center">
          <div class="text-dark-text-secondary mb-4 text-center">Start a voice chat with your sidekick.</div>
          <div class="flex items-center gap-2 mb-2">
            <button id="voiceStartBtn" class="inline-flex items-center gap-2 px-4 py-2 bg-brand-teal text-white rounded-lg hover:bg-brand-teal/90 transition-all" onclick="withBtnLoading(this, startVoice)">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 1a3 3 0 013 3v7a3 3 0 11-6 0V4a3 3 0 013-3zm7 10a7 7 0 01-14 0M5 21h14"/></svg>
              <span>Start Voice Chat</span>
            </button>
          </div>
          <div id="voiceTranscriptList" class="w-full max-w-xl mx-auto flex-1 overflow-y-auto space-y-3 mb-3"></div>
          <div id="agentSpeakingIndicator" class="hidden mb-2">
            <div class="flex items-center gap-2 text-dark-text-secondary text-sm">
              <span>Agent speaking</span>
              <div class="flex space-x-1">
                <div class="w-2 h-2 bg-brand-teal rounded-full animate-bounce" style="animation-delay:0ms"></div>
                <div class="w-2 h-2 bg-brand-teal rounded-full animate-bounce" style="animation-delay:150ms"></div>
                <div class="w-2 h-2 bg-brand-teal rounded-full animate-bounce" style="animation-delay:300ms"></div>
              </div>
            </div>
          </div>
          <div id="voiceStatus" class="text-xs text-dark-text-secondary text-center"></div>
          <div class="flex items-center gap-2 mt-2">
            <button id="voiceEndBtn" class="hidden inline-flex items-center gap-2 px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-500 transition-all" onclick="withBtnLoading(this, endVoice)">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
              <span>End Call</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    function setBtnLoading(btn, isLoading){ try { if(!btn) return; btn.classList.toggle('btn-loading', !!isLoading); btn.disabled = !!isLoading; } catch{} }
    async function withBtnLoading(btn, fn){ setBtnLoading(btn, true); try { return await fn(); } finally { setBtnLoading(btn, false); } }
    const CLIENT_ID = "{{ client_id }}";
    const AGENT_SLUG = "{{ agent_slug }}";
    const SUPABASE_URL = "{{ supabase_url }}";
    const SUPABASE_ANON = "{{ supabase_anon_key }}";
    const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON);
    let session = null;
    let manualToken = null; // token provided by parent preview via postMessage
    const urlParams = new URLSearchParams(location.search);
    const SOURCE = urlParams.get('source') || '';
    let transcriptEventSource = null;
    
    // Initialize citations component
    const citationsComponent = new CitationsComponent();

    async function ensureSession() {
      if (manualToken) { return true; }
      const { data } = await sb.auth.getSession();
      session = data?.session || null;
      return !!session;
    }
    function setAuthVisible(v) { document.getElementById('auth').classList.toggle('hidden', !v); }
    function setChatVisible(v) { document.getElementById('chat').classList.toggle('hidden', !v); }

    async function login() {
      const email = document.getElementById('email').value.trim();
      const password = document.getElementById('password').value;
      const res = await sb.auth.signInWithPassword({ email, password });
      if (res.error) { document.getElementById('auth-msg').innerText = res.error.message; return; }
      await ensureSession(); setAuthVisible(false); setChatVisible(true);
    }
    async function signup() {
      const email = document.getElementById('email').value.trim();
      const password = document.getElementById('password').value;
      const res = await sb.auth.signUp({ email, password });
      if (res.error) { document.getElementById('auth-msg').innerText = res.error.message; return; }
      document.getElementById('auth-msg').innerText = 'Check your email to confirm.';
    }

    function switchTab(t) {
      const textBtn = document.getElementById('tab-text');
      const voiceBtn = document.getElementById('tab-voice');
      if (t==='text') {
        textBtn.className = 'mode-btn flex-1 py-2 px-4 rounded-md text-sm font-medium bg-brand-teal text-white';
        voiceBtn.className = 'mode-btn flex-1 py-2 px-4 rounded-md text-sm font-medium bg-dark-elevated text-dark-text border border-dark-border';
        document.getElementById('panel-text').classList.remove('hidden');
        document.getElementById('panel-voice').classList.add('hidden');
      } else {
        voiceBtn.className = 'mode-btn flex-1 py-2 px-4 rounded-md text-sm font-medium bg-brand-teal text-white';
        textBtn.className = 'mode-btn flex-1 py-2 px-4 rounded-md text-sm font-medium bg-dark-elevated text-dark-text border border-dark-border';
        document.getElementById('panel-voice').classList.remove('hidden');
        document.getElementById('panel-text').classList.add('hidden');
      }
    }

    function addUser(text) {
      const wrap = document.createElement('div'); wrap.className='flex justify-end';
      wrap.innerHTML = `<div class="w-3/4 px-4 py-2 rounded-lg bg-brand-teal text-white">${text}</div>`;
      document.getElementById('chatMessages').appendChild(wrap);
      scrollBottom();
    }
    function addAsstHtml(html) {
      const wrap = document.createElement('div'); wrap.className='flex justify-start';
      const b = document.createElement('div'); b.className='w-3/4 px-4 py-2 rounded-lg bg-dark-elevated text-dark-text border border-dark-border whitespace-pre-wrap';
      b.innerHTML = html; wrap.appendChild(b);
      document.getElementById('chatMessages').appendChild(wrap);
      scrollBottom();
    }
    function scrollBottom(){ const el = document.getElementById('chatMessages'); el.scrollTop = el.scrollHeight; }

    async function sendMsg(evt){
      if (evt && evt.preventDefault) evt.preventDefault();
      const ok = await ensureSession(); if (!ok) { setAuthVisible(true); setChatVisible(false); return false; }
      const input = document.getElementById('msg');
      const text = input.value; if (!text) return false;
      input.value = '';
      addUser(text);
      // Insert loading indicator like preview
      const chatMessages = document.getElementById('chatMessages');
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'flex justify-start';
      loadingDiv.id = 'tempLoadingIndicator';
      loadingDiv.innerHTML = `<div class="w-3/4 px-4 py-2 rounded-lg bg-dark-elevated text-dark-text border border-dark-border"><div class="flex space-x-2"><div class="w-2 h-2 bg-brand-teal rounded-full animate-bounce" style="animation-delay:0ms"></div><div class="w-2 h-2 bg-brand-teal rounded-full animate-bounce" style="animation-delay:150ms"></div><div class="w-2 h-2 bg-brand-teal rounded-full animate-bounce" style="animation-delay:300ms"></div></div></div>`;
      chatMessages.appendChild(loadingDiv);
      // stream (FormData to match server Form(...))
      const fd = new FormData(); fd.append('client_id', CLIENT_ID); fd.append('agent_slug', AGENT_SLUG); fd.append('message', text);
      const bearer = manualToken || (session && session.access_token) || '';
      const res = await fetch('/api/embed/text/stream', { method: 'POST', body: fd, headers: { Authorization: `Bearer ${bearer}` } });
      if (!res.ok || !res.body) {
        const errDiv = document.createElement('div'); errDiv.className='flex justify-start';
        errDiv.innerHTML = `<div class="w-3/4 px-4 py-2 rounded-lg bg-dark-elevated text-dark-text border border-dark-border">Sorry, streaming failed.</div>`;
        try { chatMessages.replaceChild(errDiv, loadingDiv); } catch { chatMessages.appendChild(errDiv); }
        return false;
      }
      const reader = res.body.getReader(); const decoder = new TextDecoder(); let buf='';
      let acc = '';
      const asstDiv = document.createElement('div'); asstDiv.className='flex flex-col items-start';
      const asstBubble = document.createElement('div'); asstBubble.className='w-3/4 px-4 py-2 rounded-lg bg-dark-elevated text-dark-text border border-dark-border whitespace-pre-wrap'; asstBubble.textContent=''; asstDiv.appendChild(asstBubble);
      let inserted = false;
      while(true){
        const {value, done} = await reader.read(); if (done) break;
        buf += decoder.decode(value, {stream:true}); buf = buf.replace(/\r\n/g,'\n');
        const parts = buf.split('\n\n'); buf = parts.pop();
        for(const p of parts){ if(!p.startsWith('data: ')) continue; try{
          const payload = JSON.parse(p.slice(6));
          if (payload.error) {
            if (!inserted){ chatMessages.replaceChild(asstDiv, loadingDiv); inserted = true; }
            const msg = payload.error === 'unauthorized' ? 'Please sign in to chat.' : 'Sorry, streaming failed.';
            asstBubble.textContent = msg;
            if (payload.error === 'unauthorized') { setAuthVisible(true); setChatVisible(false); }
          }
          if(payload.delta){
            if (!inserted){ chatMessages.replaceChild(asstDiv, loadingDiv); inserted = true; }
            acc += String(payload.delta).replace(/\\n/g,'\n');
            asstBubble.innerHTML = (window.marked && window.DOMPurify) ? DOMPurify.sanitize(marked.parse(acc)) : acc;
          }
          if(payload.done && payload.full_text){
            if (!inserted){ chatMessages.replaceChild(asstDiv, loadingDiv); inserted = true; }
            acc = String(payload.full_text).replace(/\\n/g,'\n');
            asstBubble.innerHTML = (window.marked && window.DOMPurify) ? DOMPurify.sanitize(marked.parse(acc)) : acc;
            
            // Handle citations if present
            if (payload.citations && payload.citations.length > 0) {
              const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
              const citationsElement = citationsComponent.render(payload.citations, messageId);
              if (citationsElement) {
                // Add compact class for embed context
                citationsElement.classList.add('compact');
                asstDiv.appendChild(citationsElement);
                scrollBottom();
              }
            }
          }
        }catch{}}
      }
      // If stream ended without any insertion, show a fallback message
      if (!inserted) {
        const errDiv = document.createElement('div'); errDiv.className='flex justify-start';
        errDiv.innerHTML = `<div class="w-3/4 px-4 py-2 rounded-lg bg-dark-elevated text-dark-text border border-dark-border">No response received.</div>`;
        try { chatMessages.replaceChild(errDiv, loadingDiv); } catch { chatMessages.appendChild(errDiv); }
      }
      return false;
    }

    let __roomConn = null;
    let __seenTranscriptIds = new Set();
    function appendVoiceTranscript(role, text, createdAt, citations, id){
      try {
        if (id && __seenTranscriptIds.has(id)) { return; }
        const container = document.getElementById('voiceTranscriptList');
        if (!container) return;
        const wrap = document.createElement('div');
        const isUser = role === 'user';
        wrap.className = isUser ? 'flex justify-end' : 'flex justify-start';
        const bubble = document.createElement('div');
        bubble.className = (isUser
          ? 'max-w-[80%] px-4 py-2 rounded-lg bg-brand-teal text-white'
          : 'max-w-[80%] px-4 py-2 rounded-lg bg-dark-elevated text-dark-text border border-dark-border whitespace-pre-wrap');
        bubble.textContent = text || '';
        wrap.appendChild(bubble);
        container.appendChild(wrap);
        if (citations && Array.isArray(citations) && citations.length > 0) {
          const citationsElement = citationsComponent.render(citations, `voice-${Date.now()}`);
          if (citationsElement) {
            citationsElement.classList.add('compact');
            const citeWrap = document.createElement('div');
            citeWrap.className = 'flex justify-start';
            citeWrap.appendChild(citationsElement);
            container.appendChild(citeWrap);
          }
        }
        container.scrollTop = container.scrollHeight;
        if (id) { __seenTranscriptIds.add(id); }
      } catch {}
    }

    function startVoiceTranscriptStream(conversationId, clientId, agentId){
      try {
        // Guard: if already connected, don't start another SSE
        if (transcriptEventSource && transcriptEventSource.readyState !== EventSource.CLOSED) {
          try { console.log('[voice] SSE already active; skip reopening'); } catch {}
          return;
        }
        if (transcriptEventSource) { try { transcriptEventSource.close(); } catch {} transcriptEventSource = null; }
        if (!conversationId || !clientId) { try { console.warn('[voice] no conversationId or clientId; skipping SSE'); } catch {} return; }
        const params = new URLSearchParams({
          conversation_id: conversationId,
          client_id: clientId,
          agent_id: agentId || '' ,
          include_citations: 'true'
        });
        const url = `/api/v1/voice-transcripts/stream?${params.toString()}`;
        try { console.log('[voice] starting SSE', { url }); } catch {}
        transcriptEventSource = new EventSource(url);
        transcriptEventSource.onopen = async () => {
          try { console.log('[voice] SSE connected'); } catch {}
          // Prefetch recent history once on connect to avoid missing items if SSE attached late
          try {
            const historyUrl = `/api/v1/voice-transcripts/history?conversation_id=${encodeURIComponent(conversationId)}&client_id=${encodeURIComponent(clientId)}&agent_id=${encodeURIComponent(agentId||'')}&include_citations=true&limit=10`;
            const resp = await fetch(historyUrl);
            if (resp.ok) {
              const obj = await resp.json();
              if (obj && obj.success && Array.isArray(obj.data)) {
                for (const t of obj.data) {
                  const txt = t.content || t.transcript || '';
                  if (txt) {
                    appendVoiceTranscript(t.role, txt, t.created_at, t.citations, t.id);
                  }
                }
              }
            }
          } catch (e) { try { console.warn('[voice] history fetch failed', e); } catch {} }
        };
        transcriptEventSource.onmessage = (evt) => {
          try {
            const data = JSON.parse(evt.data || '{}');
            try { console.log('[voice] SSE event', { id: data?.id, role: data?.role, len: (data?.content || data?.transcript || '').length }); } catch {}
            if (data && data.role && (data.content || data.transcript)) {
              appendVoiceTranscript(data.role, data.content || data.transcript || '', data.created_at, data.citations, data.id);
            }
          } catch {}
        };
        transcriptEventSource.onerror = (e) => {
          try { console.warn('[voice] SSE error', e); } catch {}
          // Reset handle if closed so future calls can reconnect
          try { if (transcriptEventSource && transcriptEventSource.readyState === EventSource.CLOSED) { transcriptEventSource = null; } } catch {}
        };
      } catch {}
    }

    // Removed overlay in favor of autoplay under user gesture

    async function startVoice(){
      // Allow either a Supabase session OR a manual token from admin preview
      const ok = await ensureSession();
      const injectedUserId = window.__client_user_id || null;
      const hasSupabaseUser = !!(session && session.user && session.user.id);
      const hasManualToken = !!manualToken;
      if (!hasSupabaseUser && !hasManualToken) { setAuthVisible(true); setChatVisible(false); document.getElementById('voiceStatus').textContent = 'Please sign in to start voice.'; return; }
      const room = `embed_${AGENT_SLUG}_${Date.now()}`;
      const payload = {
        agent_slug: AGENT_SLUG,
        client_id: CLIENT_ID,
        mode: 'voice',
        room_name: room,
        platform: 'livekit',
        user_id: (hasSupabaseUser ? session.user.id : (injectedUserId || 'preview-user'))
      };
      const bearer = manualToken || (session && session.access_token) || '';
      const res = await fetch('/api/v1/trigger-agent', { method: 'POST', headers: { 'Content-Type':'application/json', Authorization: `Bearer ${bearer}` }, body: JSON.stringify(payload) });
      const status = document.getElementById('voiceStatus');
      const startBtn = document.getElementById('voiceStartBtn');
      const endBtn = document.getElementById('voiceEndBtn');
      // Prime Web Audio on user gesture so playback can start without overlays
      try {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) {
          if (!window.__audioCtx) { window.__audioCtx = new AC(); }
          await window.__audioCtx.resume();
        }
      } catch {}
      // Prepare a dedicated audio element under the user's gesture for autoplay reliability
      try {
        if (!window.__lk_audio_el) {
          const audio = document.createElement('audio');
          audio.autoplay = true;
          audio.playsInline = true;
          audio.muted = false;
          try { audio.volume = 1.0; } catch {}
          audio.style.position = 'fixed';
          audio.style.bottom = '8px';
          audio.style.right = '8px';
          audio.style.width = '0px';
          audio.style.height = '0px';
          audio.style.opacity = '0';
          audio.style.pointerEvents = 'none';
          document.body.appendChild(audio);
          window.__lk_audio_el = audio;
        }
        try { window.__lk_audio_el.play?.().catch(() => {}); } catch {}
      } catch {}
      if (!res.ok) { status.textContent = 'Voice start failed.'; return; }
      const data = await res.json();
      try { console.log('[voice] trigger response', data); } catch {}
      if (!data || !data.data) { status.textContent = 'Error: trigger-agent returned no data payload.'; console.log('[voice] trigger payload (raw)', data); return; }
      const info = data.data.livekit_config; const server = info?.server_url; const token = info?.user_token;
      const agentId = (data?.data?.agent_context?.agent_id || data?.agent_context?.agent_id || '');
      // Enforce no-fallback: require top-level conversation_id only
      const conversationId = data?.data?.conversation_id || null;
      try { console.log('[voice] trigger keys', Object.keys(data||{})); } catch {}
      try { console.log('[voice] conversationId', conversationId); } catch {}
      if (!conversationId) { status.textContent = 'Error: missing conversation_id from trigger-agent.'; return; }
      // Start transcript stream immediately when we have the conversationId
      try { startVoiceTranscriptStream(conversationId, CLIENT_ID, agentId); } catch {}
      if (!server || !token) { status.textContent = 'Voice start response incomplete.'; return; }
      status.textContent = 'Connecting…';
      try {
        const { Room, RoomEvent, createLocalAudioTrack, ParticipantKind } = window.LivekitClient || window.LiveKit || {};
        if (!Room) { status.textContent = 'Voice SDK not available.'; return; }
        const roomConn = new Room();
        // Prime audio playback under user gesture BEFORE connecting (non-blocking)
        try { roomConn.startAudio?.().catch(() => {}); } catch {}
        __roomConn = roomConn;
        startBtn.classList.add('hidden');
        endBtn.classList.remove('hidden');
        // Register diagnostics BEFORE connecting so we see early failures
        try { roomConn.on(RoomEvent.ConnectionStateChanged, (state) => { try { console.log('[voice] connection state', state); } catch {} }); } catch {}
        try { roomConn.on(RoomEvent.AudioPlaybackStatusChanged, () => { try { console.log('[voice] AudioPlaybackStatusChanged canPlaybackAudio=', roomConn.canPlaybackAudio); } catch {} }); } catch {}
        try { roomConn.on(RoomEvent.TrackSubscriptionFailed, (sid, err) => { try { console.error('[voice] TrackSubscriptionFailed', sid, err); } catch {} }); } catch {}
        try { roomConn.on(RoomEvent.TrackUnsubscribed, (track, pub, participant) => { try { console.warn('[voice] TrackUnsubscribed', track?.kind, participant?.identity); } catch {} }); } catch {}
        try { roomConn.on(RoomEvent.Disconnected, (reason) => { try { console.warn('[voice] Room disconnected', reason); } catch {} }); } catch {}
        // Connect with a timeout to avoid indefinite spinner
        const connectTimeoutMs = 15000;
        try {
          const connectPromise = roomConn.connect(server, token, { autoSubscribe: true });
          await Promise.race([
            connectPromise,
            new Promise((_, rej) => setTimeout(() => rej(new Error('connect-timeout')), connectTimeoutMs))
          ]);
        } catch (err) {
          try { console.error('[voice] connect failed or timed out', err); } catch {}
          status.textContent = 'Connection failed. Please try again.';
          startBtn.classList.remove('hidden');
          endBtn.classList.add('hidden');
          try { await roomConn.disconnect(); } catch {}
          return;
        }
        try { roomConn.startAudio?.().catch(() => {}); } catch {}
        // Create local mic track (non-blocking) – avoid hanging on permission prompts
        try {
          createLocalAudioTrack({
            echoCancellation: true,
            noiseSuppression: false,
            autoGainControl: true,
          })
          .then((mic) => roomConn.localParticipant.publishTrack(mic, {
            dtx: false,
            red: false,
            simulcast: false,
            maxBitrate: 64000,
          }))
          .then(() => { try { console.log('[voice] Mic track published'); } catch {} })
          .catch((e) => { try { console.warn('[voice] Mic setup/publish failed', e); } catch {} });
        } catch {}

        // Diagnostics: local track published
        try {
          roomConn.on(RoomEvent.LocalTrackPublished, (pub) => {
            try { console.log('[voice] LocalTrackPublished', { kind: pub.kind, trackSid: pub.trackSid }); } catch {}
          });
        } catch {}
        try {
          roomConn.on(RoomEvent.ActiveSpeakersChanged, (speakers) => {
            try { console.log('[voice] ActiveSpeakers', speakers?.map?.(s => ({ id: s.identity, lvl: s.audioLevel })) || speakers); } catch {}
          });
        } catch {}
        roomConn.on(RoomEvent.TrackSubscribed, (track, pub, participant) => {
          try { console.log('[voice] TrackSubscribed', track.kind, participant.identity, participant.kind); } catch {}
          if (track.kind === 'audio') {
            let el = window.__lk_audio_el;
            try {
              if (el) { track.attach(el); }
              else {
                el = track.attach();
                el.autoplay = true;
                el.playsInline = true;
                el.muted = false;
                try { el.volume = 1.0; } catch {}
                // Avoid display:none to prevent autoplay restrictions in some browsers
                el.style.position = 'fixed';
                el.style.bottom = '8px';
                el.style.right = '8px';
                el.style.width = '0px';
                el.style.height = '0px';
                el.style.opacity = '0';
                el.style.pointerEvents = 'none';
                document.body.appendChild(el);
                window.__lk_audio_el = el;
              }
            } catch {}
            (async () => {
              try { await roomConn.startAudio?.(); } catch {}
              try { await el.play?.(); } catch (e) { try { console.warn('[voice] el.play failed', e); } catch {} }
            })();
            try { status.textContent = 'Agent audio connected.'; } catch {}
          }
        });
        roomConn.on(RoomEvent.ParticipantConnected, (p) => {
          try {
            const agentKind = (ParticipantKind && ParticipantKind.AGENT) || 'agent';
            if (p && (p.kind === agentKind || String(p.identity||'').toLowerCase().includes('agent'))) {
              status.textContent = 'Agent connected. You can speak now.';
            } else {
              status.textContent = 'Connected. You can speak now.';
            }
          } catch {}
        });
        try {
          roomConn.on(RoomEvent.ActiveSpeakersChanged, (speakers) => {
            try {
              const indicator = document.getElementById('agentSpeakingIndicator');
              const anyAgentSpeaking = (speakers||[]).some(s => String(s.identity||'').toLowerCase().includes('agent') && (s.audioLevel||0) > 0);
              if (indicator){ indicator.classList.toggle('hidden', !anyAgentSpeaking); }
            } catch {}
          });
        } catch {}
        roomConn.on(RoomEvent.ParticipantDisconnected, () => { try { status.textContent = 'Participant left.'; } catch {} });
        // Fallback: after 8s, if no agent or remote audio subscribed, notify user
        setTimeout(() => {
          try {
            const participants = Array.from(roomConn.remoteParticipants.values());
            const hasAgent = participants.some((rp) => String(rp.identity||'').toLowerCase().includes('agent'));
            const hasRemoteAudio = participants.some((rp) => Array.from(rp.tracks.values()).some(t => t && t.track && t.track.kind === 'audio'));
            if (!hasAgent) { status.textContent = 'Waiting for agent to join…'; }
            else if (!hasRemoteAudio) { status.textContent = 'Agent joined but no audio yet…'; }
          } catch {}
        }, 8000);
        status.textContent = 'Connected. You can speak now.';
        if (conversationId) { startVoiceTranscriptStream(conversationId, CLIENT_ID, agentId); }
      } catch (e) {
        status.textContent = 'Connection failed.';
        startBtn.classList.remove('hidden');
        endBtn.classList.add('hidden');
      }
    }

    async function endVoice(){
      const status = document.getElementById('voiceStatus');
      const startBtn = document.getElementById('voiceStartBtn');
      const endBtn = document.getElementById('voiceEndBtn');
      try {
        try { if (transcriptEventSource) { transcriptEventSource.close(); } } catch {}
        transcriptEventSource = null;
        if (__roomConn) {
          try {
            const pubs = Array.from(__roomConn.localParticipant.tracks.values());
            for (const pub of pubs) { try { await pub.unpublish?.(); } catch {} }
          } catch {}
          await __roomConn.disconnect();
        }
      } catch {}
      __roomConn = null;
      status.textContent = 'Call ended.';
      endBtn.classList.add('hidden');
      startBtn.classList.remove('hidden');
    }

    // Listen for admin preview postMessage with Supabase tokens
    window.addEventListener('message', async (evt) => {
      try {
        const data = evt && evt.data ? evt.data : null;
        if (!data || data.type !== 'supabase-session') return;
        if (data.access_token) {
          manualToken = data.access_token;
          if (data.client_user_id) { window.__client_user_id = data.client_user_id; }
          // If refresh_token is provided, set full Supabase session for a seamless experience
          if (data.refresh_token && sb && sb.auth && sb.auth.setSession) {
            try {
              await sb.auth.setSession({ access_token: data.access_token, refresh_token: data.refresh_token });
              const { data: s } = await sb.auth.getSession();
              session = (s && s.session) ? s.session : null;
            } catch (e) { /* fallback to manual token only */ }
          }
          setAuthVisible(false); setChatVisible(true);
          try { document.getElementById('voiceStartBtn').disabled = false; } catch {}
        }
      } catch {}
    });

    // If loaded inside admin modal, make subtle style tweaks
    (function(){
      if (SOURCE === 'admin') {
        try { document.body.style.background = 'transparent'; } catch {}
      }
    })();

    (async ()=>{ const ok = await ensureSession(); setAuthVisible(!ok); setChatVisible(ok); try { document.getElementById('voiceStartBtn').disabled = !ok; } catch {} })();
  </script>
</body>
</html>


