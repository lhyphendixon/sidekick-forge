<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sidekick Embed</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'brand-teal': '#01a4a6',
            'brand-orange': '#fc7244',
            'dark-bg': '#000000',
            'dark-surface': 'rgb(20, 20, 20)',
            'dark-elevated': '#252525',
            'dark-border': '#2a2a2a',
            'dark-text': '#e0e0e0',
            'dark-text-secondary': '#a0a0a0'
          }
        }
      }
    }
  </script>
  <style>
    html, body { height: 100%; }
    html { background: #000000 !important; }
    body { margin: 0; background: #000000 !important; color:#e0e0e0; height:100%; }
    * { background-color: inherit; }
    .htmx-indicator { opacity: 0; transition: opacity 300ms ease; }
    .htmx-request .htmx-indicator { opacity: 1; }
    /* Button inline loading */
    .btn-loading { position: relative; opacity: 0.9; pointer-events: none; }
    .btn-loading > * { visibility: hidden; }
    .btn-loading::after { content:""; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:16px; height:16px; border:2px solid #2a2a2a; border-top-color:#01a4a6; border-radius:9999px; animation: spin 0.9s linear infinite; }
    @keyframes spin { 0%{transform:translate(-50%,-50%) rotate(0deg);} 100%{transform:translate(-50%,-50%) rotate(360deg);} }
    /* Force black background on everything */
    body, html {
      background: #000000 !important;
      background-color: #000000 !important;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.47.10/dist/umd/supabase.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/livekit-client@2/dist/livekit-client.umd.min.js"></script>
  <link rel="stylesheet" href="/static/css/citations.css">
  <script src="/static/js/citations.js"></script>
  <script>
    // Injected by server
    const DEV_MODE = {{ 'true' if development_mode else 'false' }};
    // Short-lived token scoped to this client/agent for production-safe embeds.
    // Note: this DOES NOT replace user authentication; it's used for scope checks only.
    window.EMBED_TOKEN = "{{ embed_token }}";
  </script>
</head>
<body style="background: #000000;">
  <div class="mx-auto p-3 h-full" style="max-width: 800px;">
    <div class="bg-dark-bg border border-dark-border rounded-lg h-full flex flex-col">
      <div id="auth" class="p-4 space-y-2">
        <h3 class="text-lg text-dark-text">Sign in</h3>
        <input id="email" class="w-full bg-dark-elevated text-dark-text border border-dark-border rounded p-2" placeholder="email" />
        <input id="password" class="w-full bg-dark-elevated text-dark-text border border-dark-border rounded p-2" placeholder="password" type="password" />
        <div class="flex gap-2">
          <button class="btn-primary px-3 py-2 rounded text-sm" onclick="login()">Login</button>
          <button class="px-3 py-2 rounded text-sm border border-dark-border" onclick="signup()">Create account</button>
        </div>
        <div id="auth-msg" class="text-dark-text-secondary text-sm"></div>
      </div>
      <div id="chat" class="hidden flex-1 flex flex-col">
        <div class="p-3 border-b border-dark-border flex gap-2">
          <button id="tab-text" class="mode-btn flex-1 py-2 px-4 rounded-md text-sm font-medium bg-brand-teal text-white" onclick="switchTab('text')">Text</button>
          <button id="tab-voice" class="mode-btn flex-1 py-2 px-4 rounded-md text-sm font-medium bg-dark-elevated text-dark-text border border-dark-border" onclick="switchTab('voice')">Voice</button>
        </div>
        <div id="panel-text" class="flex-1 flex flex-col">
          <div class="flex-1 flex flex-col">
            <div id="chatMessages" class="flex-1 overflow-y-auto p-4 space-y-4">
              <div class="text-center text-dark-text-secondary text-sm py-8">
                <p>Start a conversation with your sidekick</p>
                <p class="text-xs mt-2">Messages are not saved</p>
              </div>
            </div>
            <div class="border-t border-dark-border p-3">
              <form onsubmit="return sendMsg(event)" class="flex gap-2">
                <input id="msg" name="message" placeholder="Type a message..." class="flex-1 bg-dark-elevated border-dark-border text-dark-text rounded-md px-3 py-2 border" autocomplete="off" required />
                <button type="submit" class="btn-primary px-4 py-2 rounded text-sm font-medium">Send</button>
              </form>
            </div>
          </div>
        </div>
        <div id="panel-voice" class="hidden p-4 flex-1 flex flex-col items-center">
          <div class="text-dark-text-secondary mb-4 text-center">Start a voice chat with your sidekick.</div>
          <div class="flex items-center gap-2 mb-2">
            <button id="voiceStartBtn" class="inline-flex items-center gap-2 px-4 py-2 bg-brand-teal text-white rounded-lg hover:bg-brand-teal/90 transition-all" onclick="withBtnLoading(this, startVoice)">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 1a3 3 0 013 3v7a3 3 0 11-6 0V4a3 3 0 013-3zm7 10a7 7 0 01-14 0M5 21h14"/></svg>
              <span>Start Voice Chat</span>
            </button>
          </div>
          <div id="voiceTranscriptList" class="w-full max-w-xl mx-auto flex-1 overflow-y-auto space-y-3 mb-3"></div>
          <div id="agentSpeakingIndicator" class="hidden mb-2">
            <div class="flex items-center gap-2 text-dark-text-secondary text-sm">
              <span>Agent speaking</span>
              <div class="flex space-x-1">
                <div class="w-2 h-2 bg-brand-teal rounded-full animate-bounce" style="animation-delay:0ms"></div>
                <div class="w-2 h-2 bg-brand-teal rounded-full animate-bounce" style="animation-delay:150ms"></div>
                <div class="w-2 h-2 bg-brand-teal rounded-full animate-bounce" style="animation-delay:300ms"></div>
              </div>
            </div>
          </div>
          <div id="voiceStatus" class="text-xs text-dark-text-secondary text-center"></div>
          <div class="flex items-center gap-2 mt-2">
            <button id="voiceEndBtn" class="hidden inline-flex items-center gap-2 px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-500 transition-all" onclick="withBtnLoading(this, endVoice)">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
              <span>End Call</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    try { console.log('[voice] embed script initializing'); } catch {}
    try {
      window.addEventListener('error', (event) => {
        try {
          const { message, filename, lineno, colno } = event || {};
          console.error('[voice] window error', message, filename, lineno, colno, event?.error);
        } catch {}
      });
      window.addEventListener('unhandledrejection', (event) => {
        try { console.error('[voice] unhandled rejection', event?.reason); } catch {}
      });
    } catch {}

    function setBtnLoading(btn, isLoading){ try { if(!btn) return; btn.classList.toggle('btn-loading', !!isLoading); btn.disabled = !!isLoading; } catch{} }
    async function withBtnLoading(btn, fn){ setBtnLoading(btn, true); try { return await fn(); } finally { setBtnLoading(btn, false); } }
    const CLIENT_ID = "{{ client_id }}";
    const AGENT_SLUG = "{{ agent_slug }}";
    const SUPABASE_URL = "{{ supabase_url }}";
    const SUPABASE_ANON = "{{ supabase_anon_key }}";
    const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON);
    const CLIENT_SUPABASE_URL = "{{ client_supabase_url }}";
    const CLIENT_SUPABASE_ANON = "{{ client_supabase_anon_key }}";
    const CLIENT_SUPABASE_BOOTSTRAP = {
      access_token: "{{ client_supabase_access_token | default('') }}",
      refresh_token: "{{ client_supabase_refresh_token | default('') }}"
    };
    const LIVEKIT_TRANSCRIPT_FALLBACK = Boolean(window.__enableLivekitTranscriptFallback) || (!CLIENT_SUPABASE_URL || !CLIENT_SUPABASE_ANON);
    let transcriptSupabase = null;
    let transcriptRealtimeChannel = null;
    let transcriptConversationId = null;
    let session = null;
    // manualToken is for Supabase access tokens provided by the parent (postMessage) or future SSO
    // Do NOT preload with EMBED_TOKEN, to ensure login is required if no Supabase session exists
    let manualToken = null;
    window.__lk_audio_elements = window.__lk_audio_elements || {};
    window.__lk_transcript_seen = window.__lk_transcript_seen || {};

    function iterateTrackPublications(participant, callback) {
      if (!participant || typeof callback !== 'function') { return; }
      const seen = new Set();
      const visit = (label, collection) => {
        if (!collection) { return; }
        const handleValue = (value, key) => {
          if (!value || seen.has(value)) { return; }
          seen.add(value);
          try { callback(value, label, key); } catch {}
        };
        if (typeof collection.forEach === 'function') {
          collection.forEach((value, key) => handleValue(value, key));
          return;
        }
        if (Array.isArray(collection)) {
          collection.forEach((value, index) => handleValue(value, index));
          return;
        }
        if (typeof collection === 'object' && typeof collection.values === 'function') {
          try {
            for (const value of collection.values()) {
              handleValue(value, undefined);
            }
          } catch {}
        }
      };
      try { visit('trackPublications', participant.trackPublications); } catch {}
      try { visit('audioTrackPublications', participant.audioTrackPublications); } catch {}
      try { visit('tracks', participant.tracks); } catch {}
      try { visit('audioTracks', participant.audioTracks); } catch {}
      try {
        if (typeof participant.getTrackPublications === 'function') {
          visit('getTrackPublications', participant.getTrackPublications());
        }
      } catch {}
      try {
        if (typeof participant.getAudioTrackPublications === 'function') {
          visit('getAudioTrackPublications', participant.getAudioTrackPublications());
        }
      } catch {}
    }

    function collectAudioPublications(participant) {
      const results = [];
      iterateTrackPublications(participant, (pub, source, key) => {
        const kind = String(pub?.kind || pub?.track?.kind || pub?.audioTrack?.kind || '').toLowerCase();
        if (kind === 'audio') {
          results.push({ pub, source, key });
          return;
        }
        const sourceLabel = String(pub?.source || '').toLowerCase();
        if (sourceLabel.includes('audio') || sourceLabel.includes('microphone') || sourceLabel.includes('speaker') || sourceLabel.includes('tts')) {
          results.push({ pub, source, key });
        }
      });
      return results;
    }

    function participantHasAudioTrack(participant) {
      let hasAudio = false;
      iterateTrackPublications(participant, (pub) => {
        if (hasAudio) { return; }
        const kind = String(pub?.kind || '').toLowerCase();
        if (kind === 'audio') { hasAudio = true; return; }
        const trackKind = String(pub?.track?.kind || pub?.audioTrack?.kind || '').toLowerCase();
        if (trackKind === 'audio') { hasAudio = true; }
      });
      return hasAudio;
    }

    function ensureAudioSubscribed(publication, contextLabel, level) {
      if (!publication) { return; }
      const label = contextLabel || 'subscribe';
      const useWarn = level === 'warn';
      const logFailure = (suffix, err) => {
        try {
          if (useWarn && console?.warn) { console.warn(`[voice] ${label} ${suffix}`, err); }
          else if (console?.error) { console.error(`[voice] ${label} ${suffix}`, err); }
        } catch {}
      };
      try {
        if (typeof publication.setSubscribed === 'function') {
          const result = publication.setSubscribed(true);
          if (result && typeof result.catch === 'function') {
            result.catch((err) => { logFailure('setSubscribed(audio) failed', err); });
          }
        } else if (typeof publication.subscribe === 'function') {
          const result = publication.subscribe();
          if (result && typeof result.catch === 'function') {
            result.catch((err) => { logFailure('subscribe(audio) failed', err); });
          }
        }
      } catch (err) {
        logFailure('setSubscribed(audio) threw', err);
      }
    }

    function resolvePublicationTrack(publication) {
      if (!publication) { return null; }
      const track = publication.track || publication.audioTrack;
      if (track && String(track.kind || '').toLowerCase() === 'audio') { return track; }
      if (track && !track.kind) { return track; }
      return null;
    }

    let voicePlaybackMuted = true;

    function setVoiceAudioMuted(isMuted) {
      voicePlaybackMuted = !!isMuted;

      try {
        const elementsMap = window.__lk_audio_elements || {};
        Object.values(elementsMap).forEach((el) => {
          try {
            if (!el) return;
            el.muted = voicePlaybackMuted;
            if (!voicePlaybackMuted) {
              const maybePlay = el.play?.();
              if (maybePlay && typeof maybePlay.catch === 'function') {
                maybePlay.catch((err) => {
                  try { console.warn('[voice] audio replay blocked', err); } catch {}
                  showVoicePlaybackPrompt();
                });
              }
            }
          } catch {}
        });
      } catch {}
    }

    function showVoicePlaybackPrompt(){
      try {
        const status = document.getElementById('voiceStatus');
        if (status) status.textContent = 'Audio muted. Browser blocked autoplay — interact with the page to enable audio.';
      } catch {}
    }

    function hideVoicePlaybackPrompt(){
      try {
        const status = document.getElementById('voiceStatus');
        if (status && status.textContent.toLowerCase().includes('audio muted')) {
          status.textContent = 'Audio enabled. Listening for agent.';
        }
      } catch {}
    }

    async function enableVoicePlayback(){
      const room = window.__roomConn;
      let audioEnabled = false;

      try {
        if (room?.startAudio) {
          room.startAudio().then(() => {
            try { console.log('[voice] room.startAudio resolved'); } catch {}
          }).catch((err) => {
            try { console.warn('[voice] startAudio blocked', err); } catch {}
          });
        }
      } catch (err) {
        try { console.warn('[voice] startAudio threw', err); } catch {}
      }

      try {
        const elements = Object.values(window.__lk_audio_elements || {});
        if (elements.length === 0) {
          // Ensure at least one silent element exists so autoplay can unlock
          const placeholder = document.createElement('audio');
          placeholder.autoplay = true;
          placeholder.playsInline = true;
          placeholder.muted = voicePlaybackMuted;
          placeholder.style.position = 'fixed';
          placeholder.style.bottom = '8px';
          placeholder.style.right = '8px';
          placeholder.style.width = '0px';
          placeholder.style.height = '0px';
          placeholder.style.opacity = '0';
          placeholder.style.pointerEvents = 'none';
          document.body.appendChild(placeholder);
          window.__lk_audio_elements.__placeholder = placeholder;
        }

        const toCheck = Object.values(window.__lk_audio_elements || {});
        toCheck.forEach((el) => {
          try {
            if (!el) return;
            el.autoplay = true;
            el.playsInline = true;
            el.muted = voicePlaybackMuted;
            const maybePlay = el.play?.();
            if (maybePlay && typeof maybePlay.catch === 'function') {
              maybePlay.catch((err) => {
                try { console.warn('[voice] audio play blocked', err); } catch {}
              });
            }
          } catch (playErr) {
            try { console.warn('[voice] audio play invocation failed', playErr); } catch {}
          }
        });
        audioEnabled = true;
      } catch (err) {
        try { console.warn('[voice] audio enable failed', err); } catch {}
      }

      if (audioEnabled) {
        window.__voicePlaybackPrimed = true;
        hideVoicePlaybackPrompt();
        setVoiceAudioMuted(false);
      }
      return audioEnabled;
    }

    function markTranscriptSeen(id){
      if (!id) { return false; }
      const seenMap = window.__lk_transcript_seen;
      if (!seenMap) { return false; }
      const key = String(id);
      if ((__seenTranscriptIds && __seenTranscriptIds.has(key)) || seenMap[key]) { return true; }
      seenMap[key] = true;
      try { __seenTranscriptIds?.add(key); } catch {}
      return false;
    }

    function ingestLivekitTranscript(payload, fallbackRole){
      if (!LIVEKIT_TRANSCRIPT_FALLBACK) { return; }
      try {
        if (!payload) { return; }
        const role = payload.role || fallbackRole || 'assistant';
        const createdAt = payload.createdAt || payload.created_at || new Date().toISOString();
        const text = payload.text || payload.content || payload.transcript || '';
        const citations = payload.citations || [];
        const id = payload.id || `${role}-${createdAt}-${text.slice(0,20)}`;
        if (!text) { return; }
        if (markTranscriptSeen(id)) { return; }
        appendVoiceTranscript(role, text, createdAt, citations, id);
      } catch (err) {
        try { console.warn('[voice] failed to ingest LiveKit transcript', err, payload); } catch {}
      }
    }

    function handleRemoteAudioTrack(track, pub, participant){
      if (!track || track.kind !== 'audio') { return; }
      try { console.log('[voice] handleRemoteAudioTrack', { sid: track.sid, pubSid: pub?.trackSid, participant: participant?.identity }); } catch {}

      try {
        track.setEnabled?.(true);
        track.setVolume?.(1.0);
      } catch {}

      const sidKey = pub?.trackSid || `audio-${track.sid || Date.now()}`;
      try { console.log('[voice] audio sid key', sidKey); } catch {}

      try {
        const previous = track.detach?.() || [];
        previous.forEach((node) => { try { node.remove?.(); } catch {} });
      } catch {}

      let el = window.__lk_audio_elements?.[sidKey];
      try { console.log('[voice] existing audio element?', !!el); } catch {}
      const needAttach = !el || !document.body.contains(el);
      if (needAttach) {
        try { el?.pause?.(); el?.remove?.(); } catch {}
        el = document.createElement('audio');
        el.autoplay = true;
        el.playsInline = true;
        el.muted = voicePlaybackMuted;
        try { el.volume = 1.0; } catch {}
        el.style.position = 'fixed';
        el.style.bottom = '8px';
        el.style.right = '8px';
        el.style.width = '0px';
        el.style.height = '0px';
        el.style.opacity = '0';
        el.style.pointerEvents = 'none';
        document.body.appendChild(el);
        window.__lk_audio_elements[sidKey] = el;
        try { console.log('[voice] created new audio element', sidKey); } catch {}
        if (window.__lk_audio_elements.__placeholder) {
          try { window.__lk_audio_elements.__placeholder.remove?.(); } catch {}
          delete window.__lk_audio_elements.__placeholder;
        }
      }

      try { track.attach(el); } catch {}

      try {
        console.log('[voice] attempting el.play');
        const playPromise = el.play?.();
        if (playPromise && typeof playPromise.then === 'function') {
          playPromise
            .then(() => { try { console.log('[voice] el.play resolved'); } catch {}; })
            .catch((err) => {
              try { console.warn('[voice] audio play blocked', err); } catch {}
              showVoicePlaybackPrompt();
            });
        }
      } catch (err) {
        try { console.warn('[voice] audio play failed', err); } catch {}
        showVoicePlaybackPrompt();
      }

      if (!voicePlaybackMuted) {
        hideVoicePlaybackPrompt();
      }

      try { document.getElementById('voiceStatus').textContent = 'Agent audio connected.'; } catch {}
    }

    function attachExistingRemoteAudio(roomConn){
      try {
        const mapLike = roomConn.remoteParticipants || roomConn.participants || new Map();
        const participants = Array.from(mapLike.values());
        try {
          const debugInfo = participants.map((p) => {
            const details = [];
            iterateTrackPublications(p, (pub, source, key) => {
              details.push({
                from: source,
                key,
                trackSid: pub?.trackSid || pub?.sid,
                source: pub?.source,
                kind: pub?.kind,
                isSubscribed: pub?.isSubscribed,
                hasTrack: !!(pub?.track || pub?.audioTrack)
              });
            });
            return {
              id: p?.identity,
              kind: p?.kind,
              attributes: p?.attributes,
              publications: details
            };
          });
          console.log('[voice] attachExistingRemoteAudio participants', debugInfo);
        } catch (err) {
          console.warn('[voice] attachExistingRemoteAudio logging failed', err);
        }
        participants.forEach((participant) => {
          try {
            const audioPubs = collectAudioPublications(participant);
            const seen = new Set();
            audioPubs.forEach(({ pub, source, key }) => {
              if (!pub) { return; }
              const sid = pub.trackSid || pub.sid || pub.track?.sid;
              if (sid && seen.has(sid)) { return; }
              if (sid) { seen.add(sid); }
              try {
                console.log('[voice] inspect audio pub', {
                  participant: participant?.identity,
                  trackSid: sid,
                  subscribed: pub?.isSubscribed,
                  hasTrack: !!(pub?.track || pub?.audioTrack),
                  kind: pub?.kind,
                  source: pub?.source,
                  via: source,
                  key
                });
              } catch {}
              ensureAudioSubscribed(pub, 'attachExistingRemoteAudio');
              const track = resolvePublicationTrack(pub);
              if (track && track.kind === 'audio') {
                handleRemoteAudioTrack(track, pub, participant);
              } else if (track && !track.kind) {
                handleRemoteAudioTrack(track, pub, participant);
              } else if (pub?.track && String(pub.track.kind || '').toLowerCase() === 'audio') {
                handleRemoteAudioTrack(pub.track, pub, participant);
              }
              if (pub?.on && !pub.__voice_subscribe_hook) {
                try {
                  pub.__voice_subscribe_hook = true;
                  pub.on('subscribed', (track) => {
                    try { console.log('[voice] publication subscribed callback', { trackSid: track?.sid, pubSid: pub?.trackSid }); } catch {}
                    handleRemoteAudioTrack(track, pub, participant);
                  });
                } catch {}
              }
            });
          } catch (perr) {
            try { console.warn('[voice] attachExisting participant failed', perr); } catch {}
          }
        });
      } catch (err) {
        try { console.warn('[voice] attachExistingRemoteAudio error', err); } catch {}
      }
    }
    const urlParams = new URLSearchParams(location.search);
    const SOURCE = urlParams.get('source') || '';
    
    // Initialize citations component
    const citationsComponent = new CitationsComponent();
    function showVoiceTranscriptError(message){
      const container = document.getElementById('voiceTranscriptList');
      if (!container) { return; }
      
      // Check if transcripts already exist
      const hasExistingTranscripts = container.children.length > 0 && 
        !container.querySelector('.text-center.text-red-400');
      
      if (hasExistingTranscripts) {
        // Don't clear existing transcripts, just add a banner at the top
        const existingBanner = document.getElementById('voice-transcript-error-banner');
        if (existingBanner) {
          return; // Banner already exists
        }
        
        const banner = document.createElement('div');
        banner.id = 'voice-transcript-error-banner';
        banner.className = 'mb-2 p-2 text-xs text-orange-400 border border-orange-500/30 rounded-md bg-orange-500/5';
        banner.innerHTML = `
          <p class="font-semibold mb-1">⚠️ Live updates paused</p>
          <p class="text-xs">${message}</p>
        `;
        container.insertBefore(banner, container.firstChild);
      } else {
        // No transcripts yet, show full error message
        container.innerHTML = `
          <div class="text-center text-red-400 text-sm py-4 border border-red-500/30 rounded-md bg-red-500/5">
            <p class="font-semibold mb-1">Live transcripts unavailable</p>
            <p>${message}</p>
          </div>
        `;
      }
    }
function clearVoiceTranscriptError(){
  const container = document.getElementById('voiceTranscriptList');
  if (!container) { return; }
  const banner = document.getElementById('voice-transcript-error-banner');
  if (banner) {
    banner.remove();
  }
  const standalone = container.querySelector('.text-center.text-red-400');
  if (standalone && standalone.parentElement === container) {
    container.removeChild(standalone);
    container.innerHTML = '';
  }
}
    let storedVoiceSession = null;
    let connectionMonitor = null;
    let monitorFailures = 0;
    let reconnectLock = false;
    let reconnectAttempts = 0;
    let manualVoiceEnd = false;
    let activeConversationId = null;
    let pendingTranscriptStart = null;
    function getTranscriptSupabase(){
      if (transcriptSupabase) { return transcriptSupabase; }
      if (!window.supabase) {
        try { console.warn('[voice] Supabase client library missing'); } catch {}
        showVoiceTranscriptError('Supabase client library not available.');
        return null;
      }
      if (!CLIENT_SUPABASE_URL || !CLIENT_SUPABASE_ANON) {
        try { console.warn('[voice] transcript Supabase config missing'); } catch {}
        showVoiceTranscriptError('Client Supabase credentials are missing. Please contact support.');
        return null;
      }
      transcriptSupabase = supabase.createClient(CLIENT_SUPABASE_URL, CLIENT_SUPABASE_ANON);
      if (CLIENT_SUPABASE_BOOTSTRAP.access_token) {
        transcriptSupabase.auth.setSession({
          access_token: CLIENT_SUPABASE_BOOTSTRAP.access_token,
          refresh_token: CLIENT_SUPABASE_BOOTSTRAP.refresh_token || null
        }).catch((err) => {
          console.warn('[voice] failed to bootstrap client Supabase session', err);
          showVoiceTranscriptError('Unable to authenticate with client Supabase. Please refresh and try again.');
        });
      }
      return transcriptSupabase;
    }
    async function ensureTranscriptSupabaseAuth(){
      const clientSb = getTranscriptSupabase();
      if (!clientSb) { return false; }
      try {
        // Check if we have an authenticated session
        const { data } = await clientSb.auth.getSession();
        if (data && data.session) { return true; }
        
        // Try to set session if bootstrap tokens are available
        if (CLIENT_SUPABASE_BOOTSTRAP.access_token) {
          const { data: setData, error } = await clientSb.auth.setSession({
            access_token: CLIENT_SUPABASE_BOOTSTRAP.access_token,
            refresh_token: CLIENT_SUPABASE_BOOTSTRAP.refresh_token || null
          });
          if (!error && setData?.session) { return true; }
        }
        
        // For public embeds: anon key authentication is sufficient
        // RLS policies allow anon users to read transcripts
        // Just return true to proceed with anon authentication
        try { console.info('[voice] using anon authentication for transcripts'); } catch {}
        return true;
      } catch (err) {
        try { console.warn('[voice] transcript auth check failed', err); } catch {}
        // Still return true for anon auth
        return true;
      }
    }

    async function ensureSession() {
      if (manualToken) { return true; }
      const { data } = await sb.auth.getSession();
      session = data?.session || null;
      if (session && !CLIENT_SUPABASE_BOOTSTRAP.access_token) {
        await ensureTranscriptSupabaseAuth();
      }
      return !!session;
    }
    function setAuthVisible(v) { document.getElementById('auth').classList.toggle('hidden', !v); }
    function setChatVisible(v) { document.getElementById('chat').classList.toggle('hidden', !v); }

    async function syncClientUserCredentials(email, password){
      try {
        const token = manualToken || (session && session.access_token);
        if (!token) {
          console.warn('[voice] unable to sync client user without platform token');
          return false;
        }
        const resp = await fetch('/api/embed/client-users/sync', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            client_id: CLIENT_ID,
            email,
            password
          })
        });
        if (!resp.ok) {
          console.warn('[voice] sync client user failed', await resp.text());
          return false;
        }
        return true;
      } catch (err) {
        console.warn('[voice] sync client user exception', err);
        return false;
      }
    }

    async function ensureClientSupabaseSession(email, password){
      const clientSb = getTranscriptSupabase();
      if (!clientSb || !email || !password) { return false; }
      try {
        const { data } = await clientSb.auth.getSession();
        if (data && data.session) { return true; }
      } catch {}
      const signInResponse = await clientSb.auth.signInWithPassword({ email, password });
      if (signInResponse.error) {
        const errorMessage = (signInResponse.error.message || '').toLowerCase();
        if (errorMessage.includes('invalid login') || errorMessage.includes('not found')) {
          const synced = await syncClientUserCredentials(email, password);
          if (!synced) { throw signInResponse.error; }
          const retry = await clientSb.auth.signInWithPassword({ email, password });
          if (retry.error) { throw retry.error; }
        } else {
          throw signInResponse.error;
        }
      }
      return true;
    }

    async function login() {
      const email = document.getElementById('email').value.trim();
      const password = document.getElementById('password').value;
      const res = await sb.auth.signInWithPassword({ email, password });
      if (res.error) { document.getElementById('auth-msg').innerText = res.error.message; return; }
      if (res.data?.session) {
        session = res.data.session;
      }
      try {
        await ensureClientSupabaseSession(email, password);
      } catch (err) {
        console.warn('[voice] client Supabase login failed', err);
        document.getElementById('auth-msg').innerText = 'Unable to access voice transcripts. Please try again or contact support.';
        return;
      }
      await ensureSession(); setAuthVisible(false); setChatVisible(true);
    }
    async function signup() {
      const email = document.getElementById('email').value.trim();
      const password = document.getElementById('password').value;
      const res = await sb.auth.signUp({ email, password });
      if (res.error) { document.getElementById('auth-msg').innerText = res.error.message; return; }
      const synced = await syncClientUserCredentials(email, password);
      if (!synced) {
        document.getElementById('auth-msg').innerText = 'Account created, but voice access could not be provisioned automatically.';
        return;
      }
      if (res.data?.session) {
        session = res.data.session;
        await ensureClientSupabaseSession(email, password);
      }
      document.getElementById('auth-msg').innerText = 'Check your email to confirm.';
    }

    function switchTab(t) {
      const textBtn = document.getElementById('tab-text');
      const voiceBtn = document.getElementById('tab-voice');
      if (t==='text') {
        textBtn.className = 'mode-btn flex-1 py-2 px-4 rounded-md text-sm font-medium bg-brand-teal text-white';
        voiceBtn.className = 'mode-btn flex-1 py-2 px-4 rounded-md text-sm font-medium bg-dark-elevated text-dark-text border border-dark-border';
        document.getElementById('panel-text').classList.remove('hidden');
        document.getElementById('panel-voice').classList.add('hidden');
      } else {
        voiceBtn.className = 'mode-btn flex-1 py-2 px-4 rounded-md text-sm font-medium bg-brand-teal text-white';
        textBtn.className = 'mode-btn flex-1 py-2 px-4 rounded-md text-sm font-medium bg-dark-elevated text-dark-text border border-dark-border';
        document.getElementById('panel-voice').classList.remove('hidden');
        document.getElementById('panel-text').classList.add('hidden');
      }
    }

    function addUser(text) {
      const wrap = document.createElement('div'); wrap.className='flex justify-end';
      wrap.innerHTML = `<div class="w-3/4 px-4 py-2 rounded-lg bg-brand-teal text-white">${text}</div>`;
      document.getElementById('chatMessages').appendChild(wrap);
      scrollBottom();
    }
    function addAsstHtml(html) {
      const wrap = document.createElement('div'); wrap.className='flex justify-start';
      const b = document.createElement('div'); b.className='w-3/4 px-4 py-2 rounded-lg bg-dark-elevated text-dark-text border border-dark-border whitespace-pre-wrap';
      b.innerHTML = html; wrap.appendChild(b);
      document.getElementById('chatMessages').appendChild(wrap);
      scrollBottom();
    }
    function scrollBottom(){ const el = document.getElementById('chatMessages'); el.scrollTop = el.scrollHeight; }

    async function sendMsg(evt){
      if (evt && evt.preventDefault) evt.preventDefault();
      const ok = await ensureSession(); if (!ok) { setAuthVisible(true); setChatVisible(false); return false; }
      const input = document.getElementById('msg');
      const text = input.value; if (!text) return false;
      input.value = '';
      addUser(text);
      // Insert loading indicator like preview
      const chatMessages = document.getElementById('chatMessages');
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'flex justify-start';
      loadingDiv.id = 'tempLoadingIndicator';
      loadingDiv.innerHTML = `<div class="w-3/4 px-4 py-2 rounded-lg bg-dark-elevated text-dark-text border border-dark-border"><div class="flex space-x-2"><div class="w-2 h-2 bg-brand-teal rounded-full animate-bounce" style="animation-delay:0ms"></div><div class="w-2 h-2 bg-brand-teal rounded-full animate-bounce" style="animation-delay:150ms"></div><div class="w-2 h-2 bg-brand-teal rounded-full animate-bounce" style="animation-delay:300ms"></div></div></div>`;
      chatMessages.appendChild(loadingDiv);
      // stream (FormData to match server Form(...))
      const fd = new FormData(); fd.append('client_id', CLIENT_ID); fd.append('agent_slug', AGENT_SLUG); fd.append('message', text);
      const bearer = manualToken || (session && session.access_token) || '';
      const extraHeaders = {};
      if (window.EMBED_TOKEN) { extraHeaders['X-Embed-Token'] = window.EMBED_TOKEN; }
      const res = await fetch('/api/embed/text/stream', { method: 'POST', body: fd, headers: Object.assign({ Authorization: `Bearer ${bearer}` }, extraHeaders) });
      if (!res.ok || !res.body) {
        const errDiv = document.createElement('div'); errDiv.className='flex justify-start';
        errDiv.innerHTML = `<div class="w-3/4 px-4 py-2 rounded-lg bg-dark-elevated text-dark-text border border-dark-border">Sorry, streaming failed.</div>`;
        try { chatMessages.replaceChild(errDiv, loadingDiv); } catch { chatMessages.appendChild(errDiv); }
        return false;
      }
      const reader = res.body.getReader(); const decoder = new TextDecoder(); let buf='';
      let acc = '';
      const asstDiv = document.createElement('div'); asstDiv.className='flex flex-col items-start';
      const asstBubble = document.createElement('div'); asstBubble.className='w-3/4 px-4 py-2 rounded-lg bg-dark-elevated text-dark-text border border-dark-border whitespace-pre-wrap'; asstBubble.textContent=''; asstDiv.appendChild(asstBubble);
      let inserted = false;
      while(true){
        const {value, done} = await reader.read(); if (done) break;
        buf += decoder.decode(value, {stream:true}); buf = buf.replace(/\r\n/g,'\n');
        const parts = buf.split('\n\n'); buf = parts.pop();
        for(const p of parts){ if(!p.startsWith('data: ')) continue; try{
          const payload = JSON.parse(p.slice(6));
          if (payload.error) {
            if (!inserted){ chatMessages.replaceChild(asstDiv, loadingDiv); inserted = true; }
            const msg = payload.error === 'unauthorized' ? 'Please sign in to chat.' : 'Sorry, streaming failed.';
            asstBubble.textContent = msg;
            if (payload.error === 'unauthorized') { setAuthVisible(true); setChatVisible(false); }
          }
          if(payload.delta){
            if (!inserted){ chatMessages.replaceChild(asstDiv, loadingDiv); inserted = true; }
            acc += String(payload.delta).replace(/\\n/g,'\n');
            asstBubble.innerHTML = (window.marked && window.DOMPurify) ? DOMPurify.sanitize(marked.parse(acc)) : acc;
          }
          if(payload.done && payload.full_text){
            if (!inserted){ chatMessages.replaceChild(asstDiv, loadingDiv); inserted = true; }
            acc = String(payload.full_text).replace(/\\n/g,'\n');
            asstBubble.innerHTML = (window.marked && window.DOMPurify) ? DOMPurify.sanitize(marked.parse(acc)) : acc;
            
            // Handle citations if present
            if (payload.citations && payload.citations.length > 0) {
              const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
              const citationsElement = citationsComponent.render(payload.citations, messageId);
              if (citationsElement) {
                // Add compact class for embed context
                citationsElement.classList.add('compact');
                asstDiv.appendChild(citationsElement);
                scrollBottom();
              }
            }
          }
        }catch{}}
      }
      // If stream ended without any insertion, show a fallback message
      if (!inserted) {
        const errDiv = document.createElement('div'); errDiv.className='flex justify-start';
        errDiv.innerHTML = `<div class="w-3/4 px-4 py-2 rounded-lg bg-dark-elevated text-dark-text border border-dark-border">No response received.</div>`;
        try { chatMessages.replaceChild(errDiv, loadingDiv); } catch { chatMessages.appendChild(errDiv); }
      }
      return false;
    }

    let __roomConn = null;
    let __seenTranscriptIds = new Set();
    function updateVoiceTranscript(id, text) {
      try {
        if (!id) return;
        const existing = document.querySelector(`[data-transcript-id="${id}"]`);
        if (existing) {
          const bubble = existing.querySelector('[data-transcript-text]');
          if (bubble) {
            bubble.textContent = text || '';
            // Auto-scroll to bottom
            const container = document.getElementById('voiceTranscriptList');
            if (container) {
              container.scrollTop = container.scrollHeight;
            }
          }
        }
      } catch (err) {
        try { console.warn('[voice] failed to update transcript', err); } catch {}
      }
    }

    function appendVoiceTranscript(role, text, createdAt, citations, id){
      try {
        if (id && markTranscriptSeen(id)) { return; }
        const container = document.getElementById('voiceTranscriptList');
        if (!container) return;
        const wrap = document.createElement('div');
        const isUser = role === 'user';
        wrap.className = isUser ? 'flex justify-end' : 'flex justify-start';
        if (id) wrap.setAttribute('data-transcript-id', id); // Add ID for updating
        const bubble = document.createElement('div');
        bubble.setAttribute('data-transcript-text', 'true'); // Add attribute for finding text element
        bubble.className = (isUser
          ? 'max-w-[80%] px-4 py-2 rounded-lg bg-brand-teal text-white'
          : 'max-w-[80%] px-4 py-2 rounded-lg bg-dark-elevated text-dark-text border border-dark-border whitespace-pre-wrap');
        bubble.textContent = text || '';
        wrap.appendChild(bubble);
        container.appendChild(wrap);
        if (citations && Array.isArray(citations) && citations.length > 0) {
          const citationsElement = citationsComponent.render(citations, `voice-${Date.now()}`);
          if (citationsElement) {
            citationsElement.classList.add('compact');
            const citeWrap = document.createElement('div');
            citeWrap.className = 'flex justify-start';
            citeWrap.appendChild(citationsElement);
            container.appendChild(citeWrap);
          }
        }
        container.scrollTop = container.scrollHeight;
        if (id) { __seenTranscriptIds.add(id); }
      } catch {}
    }

    async function startVoiceTranscriptStream(conversationId, clientId, agentId){
      try {
        if (!conversationId || !clientId) {
          try { console.warn('[voice] missing conversation/client id for transcript stream'); } catch {}
          showVoiceTranscriptError('Conversation metadata missing; transcripts cannot be loaded.');
          return;
        }
        const supabaseClient = getTranscriptSupabase();
        if (!supabaseClient) { return; }
        const authorized = await ensureTranscriptSupabaseAuth();
        if (!authorized) {
          try { console.warn('[voice] transcript Supabase auth unavailable'); } catch {}
          pendingTranscriptStart = { conversationId, clientId, agentId };
          return;
        }
        pendingTranscriptStart = null;
        if (transcriptConversationId !== conversationId) {
          __seenTranscriptIds?.clear?.();
        }
        transcriptConversationId = conversationId;
        stopVoiceTranscriptStream();
        transcriptRealtimeChannel = supabaseClient
          .channel(`voice-transcripts:${conversationId}`)
          .on(
            'postgres_changes',
            {
              event: 'INSERT',
              schema: 'public',
              table: 'conversation_transcripts',
              filter: `conversation_id=eq.${conversationId}`
            },
            (payload) => {
              const row = payload?.new;
              if (!row) { return; }
              const txt = row.content || row.transcript || '';
              if (!txt) { return; }
              appendVoiceTranscript(row.role, txt, row.created_at, row.citations, row.id);
            }
          )
          .on(
            'postgres_changes',
            {
              event: 'UPDATE',
              schema: 'public',
              table: 'conversation_transcripts',
              filter: `conversation_id=eq.${conversationId}`
            },
            (payload) => {
              const row = payload?.new;
              if (!row) { return; }
              const txt = row.content || row.transcript || '';
              if (!txt) { return; }
              updateVoiceTranscript(row.id, txt);
            }
          )
          .subscribe((status) => {
            if (status === 'SUBSCRIBED') {
              try { console.log('[voice] realtime subscribed for transcripts (INSERT + UPDATE)'); } catch {}
            } else if (status === 'CHANNEL_ERROR') {
              try { console.warn('[voice] transcript channel error; retrying'); } catch {}
              setTimeout(() => {
                if (transcriptConversationId === conversationId) {
                  startVoiceTranscriptStream(conversationId, clientId, agentId);
                }
              }, 2000);
            }
          });
        await loadVoiceTranscriptHistory(conversationId);
        clearVoiceTranscriptError();
      } catch (err) {
        try { console.warn('[voice] failed to start transcript stream', err); } catch {}
        showVoiceTranscriptError('Unable to start transcript stream. Please refresh and try again.');
      }
    }

    async function loadVoiceTranscriptHistory(conversationId){
      const supabaseClient = getTranscriptSupabase();
      if (!supabaseClient || !conversationId) { return; }
      const authorized = await ensureTranscriptSupabaseAuth();
      if (!authorized) { return; }
      try {
        const { data, error } = await supabaseClient
          .from('conversation_transcripts')
          .select('*')
          .eq('conversation_id', conversationId)
          .order('created_at', { ascending: true })
          .limit(200);
        if (error) {
          try { console.warn('[voice] transcript history error', error); } catch {}
          showVoiceTranscriptError('Unable to load transcript history. Please refresh to try again.');
          return;
        }
        (data || []).forEach((t) => {
          const txt = t.content || t.transcript || '';
          if (txt) {
            appendVoiceTranscript(t.role, txt, t.created_at, t.citations, t.id);
          }
        });
        if (data && data.length > 0) {
          clearVoiceTranscriptError();
        }
      } catch (err) {
        try { console.warn('[voice] transcript history fetch failed', err); } catch {}
        showVoiceTranscriptError('Unable to load transcript history. Please refresh to try again.');
      }
    }

    function stopVoiceTranscriptStream(){
      try {
        if (transcriptRealtimeChannel && transcriptSupabase) {
          transcriptSupabase.removeChannel(transcriptRealtimeChannel);
        }
      } catch (err) {
        try { console.warn('[voice] error while stopping transcript stream', err); } catch {}
      }
      transcriptRealtimeChannel = null;
    }

    function clearVoiceConnectionMonitor() {
      if (connectionMonitor) {
        clearInterval(connectionMonitor);
        connectionMonitor = null;
      }
    }

    function scheduleVoiceConnectionMonitor(roomConn) {
      clearVoiceConnectionMonitor();
      connectionMonitor = setInterval(() => {
        try {
          if (!roomConn || manualVoiceEnd) {
            monitorFailures = 0;
            return;
          }
          const state = roomConn.state;
          const participantsMap = roomConn.remoteParticipants || roomConn.participants || new Map();
          const participants = Array.from(participantsMap.values());
          const agentPresent = participants.some((rp) => String(rp.identity || '').toLowerCase().includes('agent'));

          const connectionIssue = state !== 'connected';
          const agentMissing = !agentPresent;

          if (connectionIssue || agentMissing) {
            monitorFailures += 1;
            console.warn('[voice] connection monitor detected issue', { state, agentPresent, monitorFailures });
          } else {
            monitorFailures = 0;
          }

          if (!manualVoiceEnd && connectionIssue && monitorFailures >= 3) {
            monitorFailures = 0;
            tryVoiceReconnect('monitor');
          }
        } catch (err) {
          console.warn('[voice] monitor error', err);
        }
      }, 8000);
    }

    async function tryVoiceReconnect(reason) {
      if (manualVoiceEnd) {
        console.log('[voice] reconnect skipped (manual end)');
        return;
      }
      if (!storedVoiceSession) {
        console.log('[voice] reconnect skipped (no stored session)');
        return;
      }
      if (reconnectLock) {
        return;
      }
      reconnectLock = true;
      reconnectAttempts += 1;
      if (reconnectAttempts > 5) {
        console.error('[voice] reconnect aborted after max attempts');
        reconnectLock = false;
        return;
      }
      console.log(`[voice] attempting reconnect (${reason}) attempt ${reconnectAttempts}`);
      try {
        const status = document.getElementById('voiceStatus');
        if (status) status.textContent = 'Reconnecting voice…';
        if (__roomConn) {
          try { await __roomConn.disconnect(); } catch {}
        }
        await new Promise((resolve) => setTimeout(resolve, 600));
        await connectLivekit(storedVoiceSession, true);
      } catch (err) {
        console.error('[voice] reconnect failed', reason, err);
        reconnectLock = false;
        setTimeout(() => tryVoiceReconnect(reason), 2000);
        return;
      }
      reconnectLock = false;
    }

    // Removed overlay in favor of autoplay under user gesture
    
    async function startVoice(){
      try { console.log('[voice] startVoice invoked'); } catch {}
      const status = document.getElementById('voiceStatus');
      setVoiceAudioMuted(true);
      showVoicePlaybackPrompt();
      try {
        const existingEls = window.__lk_audio_elements || {};
        Object.entries(existingEls).forEach(([key, el]) => {
          try { el?.remove?.(); } catch {}
          delete existingEls[key];
        });
        window.__lk_audio_elements = existingEls;
      } catch {}
      try {
        window.__lk_transcript_seen = {};
        __seenTranscriptIds = new Set();
      } catch {}
      let playbackPrimed = false;
      try {
        playbackPrimed = await enableVoicePlayback();
        try { console.log('[voice] enableVoicePlayback result', playbackPrimed); } catch {}
      } catch (err) {
        try { console.warn('[voice] initial enableVoicePlayback failed', err); } catch {}
      }

      // Allow either a Supabase session OR a manual token from admin preview
      try { console.log('[voice] ensuring session'); } catch {}
      const ok = await ensureSession();
      try { console.log('[voice] ensureSession complete', { ok, manualToken: !!manualToken, sessionUser: session?.user?.id }); } catch {}
      const injectedUserId = window.__client_user_id || null;
      const hasSupabaseUser = !!(session && session.user && session.user.id);
      const hasManualToken = !!manualToken;
      try { console.log('[voice] auth status', { hasSupabaseUser, hasManualToken, injectedUserId }); } catch {}
      if (!hasSupabaseUser && !hasManualToken) {
        setAuthVisible(true); setChatVisible(false);
        document.getElementById('voiceStatus').textContent = 'Please sign in to start voice.';
        try { console.warn('[voice] abort startVoice - no session or manual token'); } catch {}
        return;
      }
      const room = `embed_${AGENT_SLUG}_${Date.now()}`;
      const payload = {
        agent_slug: AGENT_SLUG,
        client_id: CLIENT_ID,
        mode: 'voice',
        room_name: room,
        platform: 'livekit',
        user_id: (hasSupabaseUser ? session.user.id : (injectedUserId || 'preview-user'))
      };
      const bearer = manualToken || (session && session.access_token) || '';
      const extraHeaders2 = {};
      if (window.EMBED_TOKEN) { extraHeaders2['X-Embed-Token'] = window.EMBED_TOKEN; }
      try { console.log('[voice] trigger payload prepared', { room, bearerPresent: !!bearer }); } catch {}
      const headers = Object.assign({ 'Content-Type':'application/json', Authorization: `Bearer ${bearer}` }, extraHeaders2);
      const res = await fetch('/api/v1/trigger-agent', { method: 'POST', headers, body: JSON.stringify(payload) });
      try { console.log('[voice] trigger request sent', payload); } catch {}
      const startBtn = document.getElementById('voiceStartBtn');
      const endBtn = document.getElementById('voiceEndBtn');
      if (!playbackPrimed && !window.__voicePlaybackPrimed) {
        if (status) status.textContent = 'Audio muted — browser blocked autoplay. Interact with the page to enable audio.';
        try { await enableVoicePlayback(); } catch {}
      }
      if (!res.ok) { status.textContent = 'Voice start failed.'; return; }
      const data = await res.json();
      try { console.log('[voice] trigger response', data); } catch {}
      if (!data || !data.data) { status.textContent = 'Error: trigger-agent returned no data payload.'; console.log('[voice] trigger payload (raw)', data); return; }
      const info = data.data.livekit_config; const server = info?.server_url; const token = info?.user_token;
      const agentId = (data?.data?.agent_context?.agent_id || data?.agent_context?.agent_id || '');
      // Enforce no-fallback: require top-level conversation_id only
      const conversationId = data?.data?.conversation_id || null;
      try { console.log('[voice] trigger keys', Object.keys(data||{})); } catch {}
      try { console.log('[voice] conversationId', conversationId); } catch {}
      if (!conversationId) { status.textContent = 'Error: missing conversation_id from trigger-agent.'; return; }
      if (!server || !token) { status.textContent = 'Voice start response incomplete.'; return; }
      if (conversationId && conversationId !== activeConversationId) {
        activeConversationId = conversationId;
        startVoiceTranscriptStream(conversationId, CLIENT_ID, agentId);
      }
      storedVoiceSession = { server, token, conversationId, agentId };
      reconnectAttempts = 0;
      monitorFailures = 0;
      manualVoiceEnd = false;
      status.textContent = 'Connecting…';
      try {
        await connectLivekit(storedVoiceSession, false);
      } catch (err) {
        console.error('[voice] connection failed', err);
        status.textContent = 'Connection failed. Please try again.';
        startBtn.classList.remove('hidden');
        endBtn.classList.add('hidden');
      }
    }

    async function connectLivekit(sessionInfo, isReconnect){
      const status = document.getElementById('voiceStatus');
      const startBtn = document.getElementById('voiceStartBtn');
      const endBtn = document.getElementById('voiceEndBtn');
      const indicator = document.getElementById('agentSpeakingIndicator');

      if (!sessionInfo || !sessionInfo.server || !sessionInfo.token) {
        throw new Error('connectLivekit missing session info');
      }

      const { server, token } = sessionInfo;
      const { Room, RoomEvent, ParticipantKind } = window.LivekitClient || window.LiveKit || {};
      try { console.log('[voice] RoomEvent keys', RoomEvent ? Object.keys(RoomEvent) : null); } catch {}
      if (!Room) {
        status.textContent = 'Voice SDK not available.';
        throw new Error('LiveKit SDK missing');
      }

      const roomConn = new Room();
      __roomConn = roomConn;
      manualVoiceEnd = false;

      if (!window.__voicePlaybackPrimed) {
        try { await enableVoicePlayback(); } catch {}
      } else {
        hideVoicePlaybackPrompt();
      }

      try {
        roomConn.startAudio?.().catch((err) => {
          try { console.warn('[voice] startAudio deferred', err); } catch {}
          showVoicePlaybackPrompt();
        });
      } catch (err) {
        try { console.warn('[voice] startAudio threw', err); } catch {}
        showVoicePlaybackPrompt();
      }

      startBtn.classList.add('hidden');
      endBtn.classList.remove('hidden');

      try { roomConn.on(RoomEvent.ConnectionStateChanged, (state) => { try { console.log('[voice] connection state', state); } catch {} }); } catch {}
      try {
        roomConn.on(RoomEvent.AudioPlaybackStatusChanged, () => {
          try { console.log('[voice] AudioPlaybackStatusChanged canPlaybackAudio=', roomConn.canPlaybackAudio); } catch {}
          if (roomConn.canPlaybackAudio) {
            hideVoicePlaybackPrompt();
          } else {
            showVoicePlaybackPrompt();
          }
        });
      } catch {}
      try {
        if (RoomEvent?.RemoteTrackSubscribed) {
          roomConn.on(RoomEvent.RemoteTrackSubscribed, (track, pub, participant) => {
            try { console.log('[voice] RemoteTrackSubscribed event', { trackSid: track?.sid, pubSid: pub?.trackSid, participant: participant?.identity }); } catch {}
            handleRemoteAudioTrack(track, pub, participant);
          });
        }
        if (RoomEvent?.RemoteTrackUnsubscribed) {
          roomConn.on(RoomEvent.RemoteTrackUnsubscribed, (track, pub, participant) => {
            try { console.warn('[voice] RemoteTrackUnsubscribed event', { trackSid: track?.sid, pubSid: pub?.trackSid, participant: participant?.identity }); } catch {}
          });
        }
      } catch {}
      try {
        roomConn.on(RoomEvent.MediaDevicesError, (error) => {
          try { console.error('[voice] MediaDevicesError', error); } catch {}
          if (status) {
            status.textContent = 'Microphone error. Please check browser permissions and retry.';
          }
          showVoicePlaybackPrompt();
        });
      } catch {}
      try {
        roomConn.on(RoomEvent.TrackSubscriptionFailed, (sid, err) => {
          try {
            console.error('[voice] TrackSubscriptionFailed', {
              trackSid: sid,
              message: err?.message || String(err || ''),
              code: err?.code,
            });
          } catch {}
        });
      } catch {}
      try {
        roomConn.on(RoomEvent.TrackPublished, (pub, participant) => {
          try {
            console.log('[voice] TrackPublished', {
              kind: pub?.kind,
              trackSid: pub?.trackSid,
              muted: pub?.isMuted,
              participant: participant?.identity,
              subscribed: pub?.isSubscribed,
            });
          } catch {}

          if (String(pub?.kind || '').toLowerCase() === 'audio') {
            ensureAudioSubscribed(pub, 'TrackPublished');
            try {
              const track = resolvePublicationTrack(pub);
              if (track) { handleRemoteAudioTrack(track, pub, participant); }
            } catch {}
            try {
              if (pub?.on && !pub.__voice_track_published_hook) {
                pub.__voice_track_published_hook = true;
                pub.on('subscribed', (track) => {
                  try { console.log('[voice] publication subscribed callback', { trackSid: track?.sid, pubSid: pub?.trackSid }); } catch {}
                  handleRemoteAudioTrack(track, pub, participant);
                });
              }
            } catch {}
          }
        });
      } catch {}
      try {
        roomConn.on(RoomEvent.TrackUnpublished, (pub, participant) => {
          try {
            console.log('[voice] TrackUnpublished', {
              kind: pub?.kind,
              trackSid: pub?.trackSid,
              participant: participant?.identity,
            });
          } catch {}
        });
      } catch {}
      try {
        roomConn.on(RoomEvent.TrackMuted, (participant, pub) => {
          try {
            console.warn('[voice] TrackMuted', {
              participant: participant?.identity,
              trackSid: pub?.trackSid,
            });
          } catch {}
        });
      } catch {}
      try {
        roomConn.on(RoomEvent.TrackUnmuted, (participant, pub) => {
          try {
            console.log('[voice] TrackUnmuted', {
              participant: participant?.identity,
              trackSid: pub?.trackSid,
            });
          } catch {}
        });
      } catch {}
      try {
        roomConn.on(RoomEvent.TrackUnsubscribed, (track, pub, participant) => {
          try {
            console.warn('[voice] TrackUnsubscribed', {
              kind: track?.kind,
              trackSid: pub?.trackSid,
              participant: participant?.identity,
            });
          } catch {}

          if (track?.kind === 'audio') {
            try {
              const nodes = track.detach?.() || [];
              nodes.forEach((node) => { try { node.remove?.(); } catch {} });
            } catch {}
            try {
              const sidKey = pub?.trackSid || `audio-${track.sid || Date.now()}`;
              if (window.__lk_audio_elements && window.__lk_audio_elements[sidKey]) {
                try {
                  const el = window.__lk_audio_elements[sidKey];
                  if (el) {
                    el.pause?.();
                    el.srcObject = null;
                  }
                } catch {}
              }
            } catch {}

            if (!manualVoiceEnd) {
              ensureAudioSubscribed(pub, 'TrackUnsubscribed-resubscribe', 'warn');
              attachExistingRemoteAudio(roomConn);
            }
          }
        });
      } catch {}
      try {
        roomConn.on(RoomEvent.Disconnected, (reason) => {
          try { console.warn('[voice] Room disconnected', reason); } catch {}
          clearVoiceConnectionMonitor();
          if (manualVoiceEnd) {
            if (status) status.textContent = 'Call ended.';
          } else {
            if (status) {
              const reasonText = (reason && reason.reason) || reason?.toString?.() || 'unknown';
              status.textContent = `Connection lost (${reasonText}). Reconnecting…`;
            }
            tryVoiceReconnect('event-disconnected');
          }
        });
      } catch {}

      const connectTimeoutMs = 15000;
      try {
        const connectPromise = roomConn.connect(server, token, { autoSubscribe: true });
        await Promise.race([
          connectPromise,
          new Promise((_, rej) => setTimeout(() => rej(new Error('connect-timeout')), connectTimeoutMs))
        ]);
      } catch (err) {
        try { await roomConn.disconnect(); } catch {}
        throw err;
      }

      scheduleVoiceConnectionMonitor(roomConn);
      reconnectAttempts = 0;
      attachExistingRemoteAudio(roomConn);
      try {
        let tries = 0;
        const maxTries = 6;
        const interval = setInterval(() => {
          tries += 1;
          attachExistingRemoteAudio(roomConn);
          if (tries >= maxTries || !__roomConn || __roomConn !== roomConn) {
            clearInterval(interval);
          }
        }, 1000);
      } catch {}

      try {
        roomConn.startAudio?.().catch((err) => {
          try { console.warn('[voice] startAudio deferred', err); } catch {}
          showVoicePlaybackPrompt();
        });
      } catch (err) {
        try { console.warn('[voice] startAudio threw', err); } catch {}
        showVoicePlaybackPrompt();
      }

      try {
        await roomConn.localParticipant.setMicrophoneEnabled(true, undefined, { preConnectBuffer: true });
        try { console.log('[voice] Microphone enabled via setMicrophoneEnabled'); } catch {}
        if (status) {
          status.textContent = 'Microphone enabled. You can speak now.';
        }
      } catch (micErr) {
        try { console.error('[voice] setMicrophoneEnabled failed', micErr); } catch {}
        if (status) {
          status.textContent = 'Microphone unavailable. Check browser permissions and retry.';
        }
        showVoicePlaybackPrompt();
      }

      try {
        roomConn.on(RoomEvent.LocalTrackPublished, (pub) => {
          try { console.log('[voice] LocalTrackPublished', { kind: pub.kind, trackSid: pub.trackSid }); } catch {}
        });
      } catch {}

      try {
        roomConn.on(RoomEvent.ActiveSpeakersChanged, (speakers) => {
          try { console.log('[voice] ActiveSpeakers', speakers?.map?.(s => ({ id: s.identity, lvl: s.audioLevel })) || speakers); } catch {}
        });
      } catch {}
      try {
        if (RoomEvent?.RemoteTrackPublished) {
          roomConn.on(RoomEvent.RemoteTrackPublished, (pub, participant) => {
            try {
              console.log('[voice] RemoteTrackPublished', {
                kind: pub?.kind,
                trackSid: pub?.trackSid,
                participant: participant?.identity,
                subscribed: pub?.isSubscribed,
              });
            } catch {}

            if (String(pub?.kind || '').toLowerCase() === 'audio') {
              ensureAudioSubscribed(pub, 'RemoteTrackPublished');
              try {
                const maybeTrack = resolvePublicationTrack(pub);
                if (maybeTrack) { handleRemoteAudioTrack(maybeTrack, pub, participant); }
              } catch {}
              try {
                if (pub?.on && !pub.__voice_remote_published_hook) {
                  pub.__voice_remote_published_hook = true;
                  pub.on('subscribed', (track) => {
                    try { console.log('[voice] pub subscribed event', { trackSid: track?.sid, pubSid: pub?.trackSid }); } catch {}
                    handleRemoteAudioTrack(track, pub, participant);
                  });
                  pub.on('unsubscribed', () => {
                    try {
                      const sidKey = pub?.trackSid;
                      if (sidKey && window.__lk_audio_elements?.[sidKey]) {
                        const el = window.__lk_audio_elements[sidKey];
                        el?.pause?.();
                        el.srcObject = null;
                      }
                    } catch {}
                  });
                }
              } catch {}
            }
          });
        }
      } catch {}
      try {
        roomConn.on(RoomEvent.DataReceived, (payload, participant, topic) => {
          try {
            const decoder = window.__lk_decoder || new TextDecoder();
            window.__lk_decoder = decoder;
            let textPayload = '';
            if (typeof payload === 'string') {
              textPayload = payload;
            } else if (payload instanceof ArrayBuffer) {
              textPayload = decoder.decode(payload);
            } else if (ArrayBuffer.isView(payload)) {
              textPayload = decoder.decode(payload.buffer);
            }
            if (!textPayload) { return; }
            let parsed = null;
            try { parsed = JSON.parse(textPayload); } catch {}
            if (parsed && (parsed.content || parsed.transcript || parsed.text)) {
              parsed.id = parsed.id || `${topic || 'data'}-${Date.now()}`;
              const pIdentity = String(participant?.identity || '').toLowerCase();
              const fallbackRole = parsed.role || (pIdentity.includes('agent') ? 'assistant' : 'user');
              ingestLivekitTranscript(parsed, fallbackRole);
            }
          } catch (err) {
            try { console.warn('[voice] failed to process LiveKit data payload', err); } catch {}
          }
        });
      } catch {}
      try {
        const transcriptionEvent = RoomEvent.TranscriptionReceived;
        if (transcriptionEvent) {
          roomConn.on(transcriptionEvent, (evt) => {
            ingestLivekitTranscript(evt, 'assistant');
          });
        }
      } catch {}

      roomConn.on(RoomEvent.TrackSubscribed, (track, pub, participant) => {
        try {
          console.log('[voice] TrackSubscribed', {
            kind: track?.kind,
            trackSid: pub?.trackSid,
            participant: participant?.identity,
            participantKind: participant?.kind,
            muted: pub?.isMuted,
          });
        } catch {}

        if (track.kind === 'audio') {
          handleRemoteAudioTrack(track, pub, participant);
        }
      });

      roomConn.on(RoomEvent.ParticipantConnected, (p) => {
        try {
          const agentKind = (ParticipantKind && ParticipantKind.AGENT) || 'agent';
          if (p && (p.kind === agentKind || String(p.identity||'').toLowerCase().includes('agent'))) {
            status.textContent = 'Agent connected. You can speak now.';
          } else {
            status.textContent = 'Connected. You can speak now.';
          }
          attachExistingRemoteAudio(roomConn);
        } catch {}
      });

      try {
        roomConn.on(RoomEvent.ActiveSpeakersChanged, (speakers) => {
          try {
            const anyAgentSpeaking = (speakers||[]).some(s => String(s.identity||'').toLowerCase().includes('agent') && (s.audioLevel||0) > 0);
            if (indicator){ indicator.classList.toggle('hidden', !anyAgentSpeaking); }
            if (anyAgentSpeaking) {
              attachExistingRemoteAudio(roomConn);
            }
          } catch {}
        });
      } catch {}

      roomConn.on(RoomEvent.ParticipantDisconnected, (participant) => {
        try { console.log('[voice] Participant disconnected', participant?.identity); } catch {}
        if (!manualVoiceEnd && participant && String(participant.identity || '').toLowerCase().includes('agent')) {
          setTimeout(() => tryVoiceReconnect('agent-left'), 1200);
        }
      });

      setTimeout(() => {
        try {
          const participants = Array.from(roomConn.remoteParticipants.values());
          const hasAgent = participants.some((rp) => String(rp.identity||'').toLowerCase().includes('agent'));
          const hasRemoteAudio = participants.some((rp) => participantHasAudioTrack(rp));
          if (!hasAgent) { status.textContent = 'Waiting for agent to join…'; }
          else if (!hasRemoteAudio) { status.textContent = 'Agent joined but no audio yet…'; }
        } catch {}
      }, 8000);

      status.textContent = isReconnect ? 'Reconnected. You can speak now.' : 'Connected. You can speak now.';
    }

    async function endVoice(){
      const status = document.getElementById('voiceStatus');
      const startBtn = document.getElementById('voiceStartBtn');
      const endBtn = document.getElementById('voiceEndBtn');
      manualVoiceEnd = true;
      hideVoicePlaybackPrompt();
      clearVoiceConnectionMonitor();
      monitorFailures = 0;
      reconnectAttempts = 0;
      try {
        stopVoiceTranscriptStream();
        if (__roomConn) {
          try {
            const locals = [];
            iterateTrackPublications(__roomConn.localParticipant, (pub) => { locals.push(pub); });
            for (const pub of locals) { try { await pub.unpublish?.(); } catch {} }
          } catch {}
          await __roomConn.disconnect();
        }
      } catch {}
      __roomConn = null;
      storedVoiceSession = null;
      status.textContent = 'Call ended.';
      endBtn.classList.add('hidden');
      startBtn.classList.remove('hidden');
      setVoiceAudioMuted(true);
      try {
        const elementsMap = window.__lk_audio_elements || {};
        Object.entries(elementsMap).forEach(([key, el]) => {
          try { el?.remove?.(); } catch {}
          delete elementsMap[key];
        });
      } catch {}
      try { window.__lk_transcript_seen = {}; __seenTranscriptIds = new Set(); } catch {}
      try { delete window.__voicePlaybackPrimed; } catch {}
    }

    // Listen for admin preview postMessage with Supabase tokens
    window.addEventListener('message', async (evt) => {
      try {
        const data = evt && evt.data ? evt.data : null;
        if (!data || data.type !== 'supabase-session') return;
        if (data.access_token) {
          manualToken = data.access_token;
          if (data.client_user_id) { window.__client_user_id = data.client_user_id; }
          // If refresh_token is provided, set full Supabase session for a seamless experience
          if (data.refresh_token && sb && sb.auth && sb.auth.setSession) {
            try {
              await sb.auth.setSession({ access_token: data.access_token, refresh_token: data.refresh_token });
              const { data: s } = await sb.auth.getSession();
              session = (s && s.session) ? s.session : null;
            } catch (e) { /* fallback to manual token only */ }
          }
          if (data.client_supabase_access_token) {
            CLIENT_SUPABASE_BOOTSTRAP.access_token = data.client_supabase_access_token;
            CLIENT_SUPABASE_BOOTSTRAP.refresh_token = data.client_supabase_refresh_token;
            const clientSb = getTranscriptSupabase();
            if (clientSb) {
              try {
                await clientSb.auth.setSession({
                  access_token: CLIENT_SUPABASE_BOOTSTRAP.access_token,
                  refresh_token: CLIENT_SUPABASE_BOOTSTRAP.refresh_token || null
                });
                if (pendingTranscriptStart) {
                  const pending = pendingTranscriptStart;
                  pendingTranscriptStart = null;
                  setTimeout(() => {
                    startVoiceTranscriptStream(pending.conversationId, pending.clientId, pending.agentId);
                  }, 250);
                } else if (storedVoiceSession && storedVoiceSession.conversationId) {
                  startVoiceTranscriptStream(storedVoiceSession.conversationId, CLIENT_ID, storedVoiceSession.agentId);
                }
              } catch (err) {
                console.warn('[voice] failed to apply client Supabase session from message', err);
              }
            }
          }
          setAuthVisible(false); setChatVisible(true);
          try { document.getElementById('voiceStartBtn').disabled = false; } catch {}
        }
      } catch {}
    });

    // If loaded inside admin modal, make subtle style tweaks
    (function(){
      if (SOURCE === 'admin') {
        try { document.body.style.background = 'transparent'; } catch {}
      }
    })();

    (async ()=>{ const ok = await ensureSession(); setAuthVisible(!ok); setChatVisible(ok); try { document.getElementById('voiceStartBtn').disabled = !ok; } catch {} })();

    // Clean up realtime subscription when page unloads to prevent orphaned connections
    window.addEventListener('beforeunload', () => {
      stopVoiceTranscriptStream();
    });

    // Pause/resume transcript streaming based on tab visibility
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && transcriptRealtimeChannel) {
        try { console.log('[voice] Tab hidden, pausing transcript realtime channel'); } catch {}
        stopVoiceTranscriptStream();
      } else if (
        !document.hidden &&
        storedVoiceSession &&
        storedVoiceSession.conversationId &&
        !transcriptRealtimeChannel
      ) {
        try { console.log('[voice] Tab visible, resuming transcript realtime channel'); } catch {}
        startVoiceTranscriptStream(storedVoiceSession.conversationId, CLIENT_ID, storedVoiceSession.agentId);
      }
    });
  </script>
</body>
</html>
